"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const jsii_query_1 = require("../lib/jsii-query");
describe('parseExpression', () => {
    test('+', () => {
        expect((0, jsii_query_1.parseExpression)('+type')).toMatchObject({
            op: 'select',
            kind: 'type',
        });
    });
    test('-', () => {
        expect((0, jsii_query_1.parseExpression)('-type')).toMatchObject({
            op: 'filter',
            kind: 'type',
            remove: true,
        });
    });
    test('.', () => {
        expect((0, jsii_query_1.parseExpression)('.type')).toMatchObject({
            op: 'filter',
            kind: 'type',
            remove: false,
        });
        expect((0, jsii_query_1.parseExpression)('type')).toMatchObject({
            op: 'filter',
            kind: 'type',
            remove: false,
        });
    });
    test('with expression', () => {
        expect((0, jsii_query_1.parseExpression)('.property:name.startsWith("x")')).toMatchObject({
            op: 'filter',
            kind: 'property',
            remove: false,
            expression: 'name.startsWith("x")',
        });
    });
});
describe('Predicate', () => {
    test('Simple', () => {
        const p = new jsii_query_1.Predicate('name.startsWith("ba")');
        expect(p.apply({ name: 'banana' })).toBeTruthy();
        expect(p.apply({ name: 'blob' })).toBeFalsy();
    });
    test('empty', () => {
        const p = new jsii_query_1.Predicate();
        expect(p.apply({ name: 'banana' })).toBeTruthy();
        expect(p.apply({ name: 'blob' })).toBeTruthy();
    });
});
describe('filtering', () => {
    test('empty filter returns everything', async () => {
        const result = await query([], 'members');
        expect(result.length).toBeGreaterThan(700);
        expect(result).toContainEqual('readonly jsii-calc.ExportedBaseClass#success: boolean');
    });
    test('filter on method name', async () => {
        const result = await query([(0, jsii_query_1.parseExpression)('method:name.includes("con")')], 'members');
        expect(result).toContainEqual('static @scope/jsii-calc-base-of-base.StaticConsumer#consume(..._args: any[]): void');
    });
    test('filter on methods but expect types', async () => {
        const result = await query([(0, jsii_query_1.parseExpression)('method:name.includes("con")')], 'types');
        expect(result).toContainEqual('class @scope/jsii-calc-base-of-base.StaticConsumer');
    });
    test('filter on type but expect members', async () => {
        const result = await query([(0, jsii_query_1.parseExpression)('class:name == "StaticConsumer"')], 'members');
        expect(result).toContainEqual('static @scope/jsii-calc-base-of-base.StaticConsumer#consume(..._args: any[]): void');
    });
    test('filter on classes with a separate expression', async () => {
        const result = await query([
            (0, jsii_query_1.parseExpression)('method:name.includes("con")'),
            (0, jsii_query_1.parseExpression)('class'),
        ], 'members');
        expect(result).toContainEqual('static @scope/jsii-calc-base-of-base.StaticConsumer#consume(..._args: any[]): void');
    });
    test('fqn is available to filter on', async () => {
        const result = await query([
            (0, jsii_query_1.parseExpression)('class:fqn.includes("base.StaticConsumer")'),
        ]);
        expect(result).toContainEqual('static @scope/jsii-calc-base-of-base.StaticConsumer#consume(..._args: any[]): void');
    });
});
async function query(exp, what = 'all') {
    const jsiiCalcDir = path.dirname(require.resolve('jsii-calc/package.json'));
    const result = await (0, jsii_query_1.jsiiQuery)({
        fileName: jsiiCalcDir,
        expressions: exp,
        returnMembers: what !== 'types',
        returnTypes: what !== 'members',
    });
    return result.map(jsii_query_1.renderElement);
}
//# sourceMappingURL=jsii-query.test.js.map