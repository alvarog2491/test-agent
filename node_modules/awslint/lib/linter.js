"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiagnosticLevel = exports.Evaluation = exports.Linter = exports.AggregateLinter = exports.LinterBase = void 0;
const util = require("util");
const reflect = require("jsii-reflect");
class LinterBase {
}
exports.LinterBase = LinterBase;
class AggregateLinter extends LinterBase {
    linters;
    constructor(...linters) {
        super();
        this.linters = linters;
    }
    get rules() {
        const ret = new Array();
        for (const linter of this.linters) {
            ret.push(...linter.rules);
        }
        return ret;
    }
    eval(assembly, options) {
        const diags = new Array();
        for (const linter of this.linters) {
            diags.push(...linter.eval(assembly, options));
        }
        return diags;
    }
}
exports.AggregateLinter = AggregateLinter;
/**
 * Evaluates a bunch of rules against some context.
 */
class Linter extends LinterBase {
    init;
    _rules = {};
    constructor(init) {
        super();
        this.init = init;
    }
    get rules() {
        return Object.values(this._rules);
    }
    /**
     * Install another rule.
     */
    add(rule) {
        if (rule.code in this._rules) {
            throw new Error(`rule "${rule.code}" already exists`);
        }
        this._rules[rule.code] = rule;
    }
    /**
     * Evaluate all rules against the context.
     */
    eval(assembly, options) {
        options = options || {};
        let ctxs = this.init(assembly);
        if (!ctxs) {
            return []; // skip
        }
        if (!Array.isArray(ctxs)) {
            ctxs = [ctxs];
        }
        const diag = new Array();
        for (const ctx of ctxs) {
            for (const rule of Object.values(this._rules)) {
                const evaluation = new Evaluation(ctx, rule, diag, options);
                rule.eval(evaluation);
            }
        }
        return diag;
    }
}
exports.Linter = Linter;
/**
 * Passed in to each rule during evaluation.
 */
class Evaluation {
    ctx;
    options;
    curr;
    diagnostics;
    constructor(ctx, rule, diagnostics, options) {
        this.ctx = ctx;
        this.options = options;
        this.curr = rule;
        this.diagnostics = diagnostics;
    }
    /**
     * Record a failure if `condition` is not truthy.
     *
     * @param condition The condition to assert.
     * @param scope Used to diagnose the location in the source, and is used in the
     * ignore pattern.
     * @param extra Used to replace %s in the default message format string.
     */
    assert(condition, scope, extra) {
        // deduplicate: skip if this specific assertion ("rule:scope") was already examined
        if (this.diagnostics.find(d => d.rule.code === this.curr.code && d.scope === scope)) {
            return condition;
        }
        const include = this.shouldEvaluate(this.curr.code, scope);
        const message = util.format(this.curr.message, extra || '');
        // Don't add a "Success" diagnostic. It will break if we run a compound
        // linter rule which consists of 3 checks with the same scope (such
        // as for example `assertSignature()`). If the first check fails, we would
        // add a "Success" diagnostic and all other diagnostics would be skipped because
        // of the deduplication check above. Changing the scope makes it worse, since
        // the scope is also the ignore pattern and they're all conceptually the same rule.
        //
        // Simplest solution is to not record successes -- why do we even need them?
        if (include && condition) {
            return condition;
        }
        let level;
        if (!include) {
            level = DiagnosticLevel.Skipped;
        }
        else if (this.curr.warning) {
            level = DiagnosticLevel.Warning;
        }
        else {
            level = DiagnosticLevel.Error;
        }
        const diag = {
            level,
            rule: this.curr,
            scope,
            message,
        };
        this.diagnostics.push(diag);
        return condition;
    }
    assertEquals(actual, expected, scope) {
        return this.assert(actual === expected, scope, ` (expected="${expected}",actual="${actual}")`);
    }
    assertTypesEqual(ts, actual, expected, scope) {
        const a = typeReferenceFrom(ts, actual);
        const e = typeReferenceFrom(ts, expected);
        return this.assert(a.toString() === e.toString(), scope, ` (expected="${e}",actual="${a}")`);
    }
    assertTypesAssignable(ts, actual, expected, scope) {
        const a = typeReferenceFrom(ts, actual);
        const e = typeReferenceFrom(ts, expected);
        return this.assert(a.toString() === e.toString() || (a.fqn && e.fqn && a.type.extends(e.type)), scope, ` ("${a}" not assignable to "${e}")`);
    }
    assertParameterOptional(actual, expected, scope) {
        return this.assert(actual === expected, scope, ` (${scope} should be ${expected ? 'optional' : 'mandatory'})`);
    }
    assertSignature(method, expectations) {
        const scope = method.parentType.fqn + '.' + method.name;
        if (expectations.returns && reflect.Method.isMethod(method)) {
            this.assertTypesEqual(method.system, method.returns.type, expectations.returns, scope);
        }
        if (expectations.parameters) {
            const expectedCount = expectations.parameters.length;
            const actualCount = method.parameters.length;
            if (this.assertEquals(actualCount, expectedCount, scope)) {
                for (let i = 0; i < expectations.parameters.length; ++i) {
                    const expect = expectations.parameters[i];
                    const actual = method.parameters[i];
                    const pscope = scope + `.params[${i}]`;
                    if (expect.name) {
                        const expectedName = expect.name;
                        const actualName = actual.name;
                        this.assertEquals(actualName, expectedName, pscope);
                    }
                    if (expect.type) {
                        if (expect.subtypeAllowed) {
                            this.assertTypesAssignable(method.system, actual.type, expect.type, pscope);
                        }
                        else {
                            this.assertTypesEqual(method.system, actual.type, expect.type, pscope);
                        }
                    }
                    if (expect.optional !== undefined) {
                        this.assertParameterOptional(actual.optional, expect.optional, pscope);
                    }
                }
            }
        }
    }
    /**
     * Evaluates whether the rule should be evaluated based on the filters applied.
     */
    shouldEvaluate(code, scope) {
        if (!this.options.includeRules || this.options.includeRules.isEmpty()) {
            return true;
        }
        if (this.options.includeRules.matches(code, scope)) {
            if (this.options.excludeRules?.matches(code, scope)) {
                return false;
            }
            return true;
        }
        return false;
    }
}
exports.Evaluation = Evaluation;
var DiagnosticLevel;
(function (DiagnosticLevel) {
    DiagnosticLevel[DiagnosticLevel["Skipped"] = 0] = "Skipped";
    DiagnosticLevel[DiagnosticLevel["Success"] = 1] = "Success";
    DiagnosticLevel[DiagnosticLevel["Warning"] = 2] = "Warning";
    DiagnosticLevel[DiagnosticLevel["Error"] = 3] = "Error";
})(DiagnosticLevel || (exports.DiagnosticLevel = DiagnosticLevel = {}));
/**
 * Convert a type specifier to a TypeReference
 */
function typeReferenceFrom(ts, x) {
    if (isTypeReference(x)) {
        return x;
    }
    if (typeof x === 'string') {
        if (x.indexOf('.') === -1) {
            return new reflect.TypeReference(ts, { primitive: x });
        }
        else {
            return new reflect.TypeReference(ts, { fqn: x });
        }
    }
    return new reflect.TypeReference(ts, x);
}
function isTypeReference(x) {
    return x instanceof reflect.TypeReference;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGludGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsibGludGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDZCQUE2QjtBQUU3Qix3Q0FBd0M7QUFpQnhDLE1BQXNCLFVBQVU7Q0FHL0I7QUFIRCxnQ0FHQztBQUVELE1BQWEsZUFBZ0IsU0FBUSxVQUFVO0lBQ3JDLE9BQU8sQ0FBZTtJQUU5QixZQUFZLEdBQUcsT0FBcUI7UUFDbEMsS0FBSyxFQUFFLENBQUM7UUFDUixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztJQUN6QixDQUFDO0lBRUQsSUFBVyxLQUFLO1FBQ2QsTUFBTSxHQUFHLEdBQUcsSUFBSSxLQUFLLEVBQVEsQ0FBQztRQUM5QixLQUFLLE1BQU0sTUFBTSxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUNsQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzVCLENBQUM7UUFDRCxPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUM7SUFFTSxJQUFJLENBQUMsUUFBMEIsRUFBRSxPQUFrQztRQUN4RSxNQUFNLEtBQUssR0FBRyxJQUFJLEtBQUssRUFBYyxDQUFDO1FBQ3RDLEtBQUssTUFBTSxNQUFNLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ2xDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBQ2hELENBQUM7UUFDRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7Q0FDRjtBQXZCRCwwQ0F1QkM7QUFFRDs7R0FFRztBQUNILE1BQWEsTUFBVSxTQUFRLFVBQVU7SUFHVjtJQUZaLE1BQU0sR0FBd0MsRUFBRyxDQUFDO0lBRW5FLFlBQTZCLElBQWtFO1FBQzdGLEtBQUssRUFBRSxDQUFDO1FBRG1CLFNBQUksR0FBSixJQUFJLENBQThEO0lBRS9GLENBQUM7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ZUFBZSwrQkFBZixlQUFlLFFBSzFCO0FBU0Q7O0dBRUc7QUFDSCxTQUFTLGlCQUFpQixDQUFDLEVBQXNCLEVBQUUsQ0FBZ0I7SUFDakUsSUFBSSxlQUFlLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQUMsQ0FBQztJQUVyQyxJQUFJLE9BQU8sQ0FBQyxLQUFLLFFBQVEsRUFBRSxDQUFDO1FBQzFCLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQzFCLE9BQU8sSUFBSSxPQUFPLENBQUMsYUFBYSxDQUFDLEVBQUUsRUFBRSxFQUFFLFNBQVMsRUFBRSxDQUFrQixFQUFFLENBQUMsQ0FBQztRQUMxRSxDQUFDO2FBQU0sQ0FBQztZQUNOLE9BQU8sSUFBSSxPQUFPLENBQUMsYUFBYSxDQUFDLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ25ELENBQUM7SUFDSCxDQUFDO0lBRUQsT0FBTyxJQUFJLE9BQU8sQ0FBQyxhQUFhLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQzFDLENBQUM7QUFFRCxTQUFTLGVBQWUsQ0FBQyxDQUFNO0lBQzdCLE9BQU8sQ0FBQyxZQUFZLE9BQU8sQ0FBQyxhQUFhLENBQUM7QUFDNUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHV0aWwgZnJvbSAndXRpbCc7XG5pbXBvcnQgeyBQcmltaXRpdmVUeXBlIH0gZnJvbSAnQGpzaWkvc3BlYyc7XG5pbXBvcnQgKiBhcyByZWZsZWN0IGZyb20gJ2pzaWktcmVmbGVjdCc7XG5pbXBvcnQgeyBSdWxlRmlsdGVyU2V0IH0gZnJvbSAnLi9ydWxlLXNwZWNzJztcblxuZXhwb3J0IGludGVyZmFjZSBMaW50ZXJPcHRpb25zIHtcbiAgLyoqXG4gICAqIExpc3Qgb2YgcnVsZXMgdG8gaW5jbHVkZS5cbiAgICogQGRlZmF1bHQgYWxsIHJ1bGVzXG4gICAqL1xuICBpbmNsdWRlUnVsZXM/OiBSdWxlRmlsdGVyU2V0O1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIHJ1bGVzIHRvIGV4Y2x1ZGUgKHRha2VzIHByZWNlZGVuY2Ugb24gXCJpbmNsdWRlXCIpXG4gICAqIEBkZWZhdWx0IG5vbmVcbiAgICovXG4gIGV4Y2x1ZGVSdWxlcz86IFJ1bGVGaWx0ZXJTZXQ7XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBMaW50ZXJCYXNlIHtcbiAgcHVibGljIGFic3RyYWN0IHJ1bGVzOiBSdWxlW107XG4gIHB1YmxpYyBhYnN0cmFjdCBldmFsKGFzc2VtYmx5OiByZWZsZWN0LkFzc2VtYmx5LCBvcHRpb25zOiBMaW50ZXJPcHRpb25zIHwgdW5kZWZpbmVkKTogRGlhZ25vc3RpY1tdO1xufVxuXG5leHBvcnQgY2xhc3MgQWdncmVnYXRlTGludGVyIGV4dGVuZHMgTGludGVyQmFzZSB7XG4gIHByaXZhdGUgbGludGVyczogTGludGVyQmFzZVtdO1xuXG4gIGNvbnN0cnVjdG9yKC4uLmxpbnRlcnM6IExpbnRlckJhc2VbXSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5saW50ZXJzID0gbGludGVycztcbiAgfVxuXG4gIHB1YmxpYyBnZXQgcnVsZXMoKTogUnVsZVtdIHtcbiAgICBjb25zdCByZXQgPSBuZXcgQXJyYXk8UnVsZT4oKTtcbiAgICBmb3IgKGNvbnN0IGxpbnRlciBvZiB0aGlzLmxpbnRlcnMpIHtcbiAgICAgIHJldC5wdXNoKC4uLmxpbnRlci5ydWxlcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBwdWJsaWMgZXZhbChhc3NlbWJseTogcmVmbGVjdC5Bc3NlbWJseSwgb3B0aW9uczogTGludGVyT3B0aW9ucyB8IHVuZGVmaW5lZCk6IERpYWdub3N0aWNbXSB7XG4gICAgY29uc3QgZGlhZ3MgPSBuZXcgQXJyYXk8RGlhZ25vc3RpYz4oKTtcbiAgICBmb3IgKGNvbnN0IGxpbnRlciBvZiB0aGlzLmxpbnRlcnMpIHtcbiAgICAgIGRpYWdzLnB1c2goLi4ubGludGVyLmV2YWwoYXNzZW1ibHksIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRpYWdzO1xuICB9XG59XG5cbi8qKlxuICogRXZhbHVhdGVzIGEgYnVuY2ggb2YgcnVsZXMgYWdhaW5zdCBzb21lIGNvbnRleHQuXG4gKi9cbmV4cG9ydCBjbGFzcyBMaW50ZXI8VD4gZXh0ZW5kcyBMaW50ZXJCYXNlIHtcbiAgcHJpdmF0ZSByZWFkb25seSBfcnVsZXM6IHsgW25hbWU6IHN0cmluZ106IENvbmNyZXRlUnVsZTxUPiB9ID0geyB9O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgaW5pdDogKGFzc2VtYmx5OiByZWZsZWN0LkFzc2VtYmx5KSA9PiBUIHwgcmVhZG9ubHkgVFtdIHwgdW5kZWZpbmVkKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgcnVsZXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5fcnVsZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc3RhbGwgYW5vdGhlciBydWxlLlxuICAgKi9cbiAgcHVibGljIGFkZChydWxlOiBDb25jcmV0ZVJ1bGU8VD4pIHtcbiAgICBpZiAocnVsZS5jb2RlIGluIHRoaXMuX3J1bGVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHJ1bGUgXCIke3J1bGUuY29kZX1cIiBhbHJlYWR5IGV4aXN0c2ApO1xuICAgIH1cblxuICAgIHRoaXMuX3J1bGVzW3J1bGUuY29kZV0gPSBydWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIGFsbCBydWxlcyBhZ2FpbnN0IHRoZSBjb250ZXh0LlxuICAgKi9cbiAgcHVibGljIGV2YWwoYXNzZW1ibHk6IHJlZmxlY3QuQXNzZW1ibHksIG9wdGlvbnM6IExpbnRlck9wdGlvbnMgfCB1bmRlZmluZWQpOiBEaWFnbm9zdGljW10ge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgfTtcblxuICAgIGxldCBjdHhzID0gdGhpcy5pbml0KGFzc2VtYmx5KTtcbiAgICBpZiAoIWN0eHMpIHtcbiAgICAgIHJldHVybiBbXTsgLy8gc2tpcFxuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShjdHhzKSkge1xuICAgICAgY3R4cyA9IFtjdHhzXSBhcyByZWFkb25seSBUW107XG4gICAgfVxuXG4gICAgY29uc3QgZGlhZyA9IG5ldyBBcnJheTxEaWFnbm9zdGljPigpO1xuXG4gICAgZm9yIChjb25zdCBjdHggb2YgY3R4cykge1xuICAgICAgZm9yIChjb25zdCBydWxlIG9mIE9iamVjdC52YWx1ZXModGhpcy5fcnVsZXMpKSB7XG4gICAgICAgIGNvbnN0IGV2YWx1YXRpb24gPSBuZXcgRXZhbHVhdGlvbihjdHgsIHJ1bGUsIGRpYWcsIG9wdGlvbnMpO1xuICAgICAgICBydWxlLmV2YWwoZXZhbHVhdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpYWc7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXNzZWQgaW4gdG8gZWFjaCBydWxlIGR1cmluZyBldmFsdWF0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgRXZhbHVhdGlvbjxUPiB7XG4gIHB1YmxpYyByZWFkb25seSBjdHg6IFQ7XG4gIHB1YmxpYyByZWFkb25seSBvcHRpb25zOiBMaW50ZXJPcHRpb25zO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgY3VycjogQ29uY3JldGVSdWxlPFQ+O1xuICBwcml2YXRlIHJlYWRvbmx5IGRpYWdub3N0aWNzOiBEaWFnbm9zdGljW107XG5cbiAgY29uc3RydWN0b3IoY3R4OiBULCBydWxlOiBDb25jcmV0ZVJ1bGU8VD4sIGRpYWdub3N0aWNzOiBEaWFnbm9zdGljW10sIG9wdGlvbnM6IExpbnRlck9wdGlvbnMpIHtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuY3VyciA9IHJ1bGU7XG4gICAgdGhpcy5kaWFnbm9zdGljcyA9IGRpYWdub3N0aWNzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY29yZCBhIGZhaWx1cmUgaWYgYGNvbmRpdGlvbmAgaXMgbm90IHRydXRoeS5cbiAgICpcbiAgICogQHBhcmFtIGNvbmRpdGlvbiBUaGUgY29uZGl0aW9uIHRvIGFzc2VydC5cbiAgICogQHBhcmFtIHNjb3BlIFVzZWQgdG8gZGlhZ25vc2UgdGhlIGxvY2F0aW9uIGluIHRoZSBzb3VyY2UsIGFuZCBpcyB1c2VkIGluIHRoZVxuICAgKiBpZ25vcmUgcGF0dGVybi5cbiAgICogQHBhcmFtIGV4dHJhIFVzZWQgdG8gcmVwbGFjZSAlcyBpbiB0aGUgZGVmYXVsdCBtZXNzYWdlIGZvcm1hdCBzdHJpbmcuXG4gICAqL1xuICBwdWJsaWMgYXNzZXJ0KGNvbmRpdGlvbjogYW55LCBzY29wZTogc3RyaW5nLCBleHRyYT86IHN0cmluZyk6IGNvbmRpdGlvbiBpcyB0cnVlIHtcbiAgICAvLyBkZWR1cGxpY2F0ZTogc2tpcCBpZiB0aGlzIHNwZWNpZmljIGFzc2VydGlvbiAoXCJydWxlOnNjb3BlXCIpIHdhcyBhbHJlYWR5IGV4YW1pbmVkXG4gICAgaWYgKHRoaXMuZGlhZ25vc3RpY3MuZmluZChkID0+IGQucnVsZS5jb2RlID09PSB0aGlzLmN1cnIuY29kZSAmJiBkLnNjb3BlID09PSBzY29wZSkpIHtcbiAgICAgIHJldHVybiBjb25kaXRpb247XG4gICAgfVxuXG4gICAgY29uc3QgaW5jbHVkZSA9IHRoaXMuc2hvdWxkRXZhbHVhdGUodGhpcy5jdXJyLmNvZGUsIHNjb3BlKTtcbiAgICBjb25zdCBtZXNzYWdlID0gdXRpbC5mb3JtYXQodGhpcy5jdXJyLm1lc3NhZ2UsIGV4dHJhIHx8ICcnKTtcblxuICAgIC8vIERvbid0IGFkZCBhIFwiU3VjY2Vzc1wiIGRpYWdub3N0aWMuIEl0IHdpbGwgYnJlYWsgaWYgd2UgcnVuIGEgY29tcG91bmRcbiAgICAvLyBsaW50ZXIgcnVsZSB3aGljaCBjb25zaXN0cyBvZiAzIGNoZWNrcyB3aXRoIHRoZSBzYW1lIHNjb3BlIChzdWNoXG4gICAgLy8gYXMgZm9yIGV4YW1wbGUgYGFzc2VydFNpZ25hdHVyZSgpYCkuIElmIHRoZSBmaXJzdCBjaGVjayBmYWlscywgd2Ugd291bGRcbiAgICAvLyBhZGQgYSBcIlN1Y2Nlc3NcIiBkaWFnbm9zdGljIGFuZCBhbGwgb3RoZXIgZGlhZ25vc3RpY3Mgd291bGQgYmUgc2tpcHBlZCBiZWNhdXNlXG4gICAgLy8gb2YgdGhlIGRlZHVwbGljYXRpb24gY2hlY2sgYWJvdmUuIENoYW5naW5nIHRoZSBzY29wZSBtYWtlcyBpdCB3b3JzZSwgc2luY2VcbiAgICAvLyB0aGUgc2NvcGUgaXMgYWxzbyB0aGUgaWdub3JlIHBhdHRlcm4gYW5kIHRoZXkncmUgYWxsIGNvbmNlcHR1YWxseSB0aGUgc2FtZSBydWxlLlxuICAgIC8vXG4gICAgLy8gU2ltcGxlc3Qgc29sdXRpb24gaXMgdG8gbm90IHJlY29yZCBzdWNjZXNzZXMgLS0gd2h5IGRvIHdlIGV2ZW4gbmVlZCB0aGVtP1xuICAgIGlmIChpbmNsdWRlICYmIGNvbmRpdGlvbikgeyByZXR1cm4gY29uZGl0aW9uOyB9XG5cbiAgICBsZXQgbGV2ZWw6IERpYWdub3N0aWNMZXZlbDtcbiAgICBpZiAoIWluY2x1ZGUpIHtcbiAgICAgIGxldmVsID0gRGlhZ25vc3RpY0xldmVsLlNraXBwZWQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnIud2FybmluZykge1xuICAgICAgbGV2ZWwgPSBEaWFnbm9zdGljTGV2ZWwuV2FybmluZztcbiAgICB9IGVsc2Uge1xuICAgICAgbGV2ZWwgPSBEaWFnbm9zdGljTGV2ZWwuRXJyb3I7XG4gICAgfVxuXG4gICAgY29uc3QgZGlhZzogRGlhZ25vc3RpYyA9IHtcbiAgICAgIGxldmVsLFxuICAgICAgcnVsZTogdGhpcy5jdXJyLFxuICAgICAgc2NvcGUsXG4gICAgICBtZXNzYWdlLFxuICAgIH07XG5cbiAgICB0aGlzLmRpYWdub3N0aWNzLnB1c2goZGlhZyk7XG5cbiAgICByZXR1cm4gY29uZGl0aW9uO1xuICB9XG5cbiAgcHVibGljIGFzc2VydEVxdWFscyhhY3R1YWw6IGFueSwgZXhwZWN0ZWQ6IGFueSwgc2NvcGU6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLmFzc2VydChhY3R1YWwgPT09IGV4cGVjdGVkLCBzY29wZSwgYCAoZXhwZWN0ZWQ9XCIke2V4cGVjdGVkfVwiLGFjdHVhbD1cIiR7YWN0dWFsfVwiKWApO1xuICB9XG5cbiAgcHVibGljIGFzc2VydFR5cGVzRXF1YWwodHM6IHJlZmxlY3QuVHlwZVN5c3RlbSwgYWN0dWFsOiBUeXBlU3BlY2lmaWVyLCBleHBlY3RlZDogVHlwZVNwZWNpZmllciwgc2NvcGU6IHN0cmluZykge1xuICAgIGNvbnN0IGEgPSB0eXBlUmVmZXJlbmNlRnJvbSh0cywgYWN0dWFsKTtcbiAgICBjb25zdCBlID0gdHlwZVJlZmVyZW5jZUZyb20odHMsIGV4cGVjdGVkKTtcbiAgICByZXR1cm4gdGhpcy5hc3NlcnQoYS50b1N0cmluZygpID09PSBlLnRvU3RyaW5nKCksIHNjb3BlLCBgIChleHBlY3RlZD1cIiR7ZX1cIixhY3R1YWw9XCIke2F9XCIpYCk7XG4gIH1cblxuICBwdWJsaWMgYXNzZXJ0VHlwZXNBc3NpZ25hYmxlKHRzOiByZWZsZWN0LlR5cGVTeXN0ZW0sIGFjdHVhbDogVHlwZVNwZWNpZmllciwgZXhwZWN0ZWQ6IFR5cGVTcGVjaWZpZXIsIHNjb3BlOiBzdHJpbmcpIHtcbiAgICBjb25zdCBhID0gdHlwZVJlZmVyZW5jZUZyb20odHMsIGFjdHVhbCk7XG4gICAgY29uc3QgZSA9IHR5cGVSZWZlcmVuY2VGcm9tKHRzLCBleHBlY3RlZCk7XG4gICAgcmV0dXJuIHRoaXMuYXNzZXJ0KGEudG9TdHJpbmcoKSA9PT0gZS50b1N0cmluZygpIHx8IChhLmZxbiAmJiBlLmZxbiAmJiBhLnR5cGUhLmV4dGVuZHMoZS50eXBlISkpLCBzY29wZSwgYCAoXCIke2F9XCIgbm90IGFzc2lnbmFibGUgdG8gXCIke2V9XCIpYCk7XG4gIH1cblxuICBwdWJsaWMgYXNzZXJ0UGFyYW1ldGVyT3B0aW9uYWwoYWN0dWFsOiBib29sZWFuLCBleHBlY3RlZDogYm9vbGVhbiwgc2NvcGU6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLmFzc2VydChhY3R1YWwgPT09IGV4cGVjdGVkLCBzY29wZSwgYCAoJHtzY29wZX0gc2hvdWxkIGJlICR7ZXhwZWN0ZWQgPyAnb3B0aW9uYWwnIDogJ21hbmRhdG9yeSd9KWApO1xuICB9XG5cbiAgcHVibGljIGFzc2VydFNpZ25hdHVyZShtZXRob2Q6IHJlZmxlY3QuQ2FsbGFibGUsIGV4cGVjdGF0aW9uczogTWV0aG9kU2lnbmF0dXJlRXhwZWN0YXRpb25zKSB7XG4gICAgY29uc3Qgc2NvcGUgPSBtZXRob2QucGFyZW50VHlwZS5mcW4gKyAnLicgKyBtZXRob2QubmFtZTtcbiAgICBpZiAoZXhwZWN0YXRpb25zLnJldHVybnMgJiYgcmVmbGVjdC5NZXRob2QuaXNNZXRob2QobWV0aG9kKSkge1xuICAgICAgdGhpcy5hc3NlcnRUeXBlc0VxdWFsKG1ldGhvZC5zeXN0ZW0sIG1ldGhvZC5yZXR1cm5zLnR5cGUsIGV4cGVjdGF0aW9ucy5yZXR1cm5zLCBzY29wZSk7XG4gICAgfVxuXG4gICAgaWYgKGV4cGVjdGF0aW9ucy5wYXJhbWV0ZXJzKSB7XG4gICAgICBjb25zdCBleHBlY3RlZENvdW50ID0gZXhwZWN0YXRpb25zLnBhcmFtZXRlcnMubGVuZ3RoO1xuICAgICAgY29uc3QgYWN0dWFsQ291bnQgPSBtZXRob2QucGFyYW1ldGVycy5sZW5ndGg7XG4gICAgICBpZiAodGhpcy5hc3NlcnRFcXVhbHMoYWN0dWFsQ291bnQsIGV4cGVjdGVkQ291bnQsIHNjb3BlKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cGVjdGF0aW9ucy5wYXJhbWV0ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY29uc3QgZXhwZWN0ID0gZXhwZWN0YXRpb25zLnBhcmFtZXRlcnNbaV07XG4gICAgICAgICAgY29uc3QgYWN0dWFsID0gbWV0aG9kLnBhcmFtZXRlcnNbaV07XG4gICAgICAgICAgY29uc3QgcHNjb3BlID0gc2NvcGUgKyBgLnBhcmFtc1ske2l9XWA7XG4gICAgICAgICAgaWYgKGV4cGVjdC5uYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZE5hbWUgPSBleHBlY3QubmFtZTtcbiAgICAgICAgICAgIGNvbnN0IGFjdHVhbE5hbWUgPSBhY3R1YWwubmFtZTtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0RXF1YWxzKGFjdHVhbE5hbWUsIGV4cGVjdGVkTmFtZSwgcHNjb3BlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4cGVjdC50eXBlKSB7XG4gICAgICAgICAgICBpZiAoZXhwZWN0LnN1YnR5cGVBbGxvd2VkKSB7XG4gICAgICAgICAgICAgIHRoaXMuYXNzZXJ0VHlwZXNBc3NpZ25hYmxlKG1ldGhvZC5zeXN0ZW0sIGFjdHVhbC50eXBlLCBleHBlY3QudHlwZSwgcHNjb3BlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuYXNzZXJ0VHlwZXNFcXVhbChtZXRob2Quc3lzdGVtLCBhY3R1YWwudHlwZSwgZXhwZWN0LnR5cGUsIHBzY29wZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleHBlY3Qub3B0aW9uYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRQYXJhbWV0ZXJPcHRpb25hbChhY3R1YWwub3B0aW9uYWwsIGV4cGVjdC5vcHRpb25hbCwgcHNjb3BlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXZhbHVhdGVzIHdoZXRoZXIgdGhlIHJ1bGUgc2hvdWxkIGJlIGV2YWx1YXRlZCBiYXNlZCBvbiB0aGUgZmlsdGVycyBhcHBsaWVkLlxuICAgKi9cbiAgcHJpdmF0ZSBzaG91bGRFdmFsdWF0ZShjb2RlOiBzdHJpbmcsIHNjb3BlOiBzdHJpbmcpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5pbmNsdWRlUnVsZXMgfHwgdGhpcy5vcHRpb25zLmluY2x1ZGVSdWxlcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuaW5jbHVkZVJ1bGVzLm1hdGNoZXMoY29kZSwgc2NvcGUpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmV4Y2x1ZGVSdWxlcz8ubWF0Y2hlcyhjb2RlLCBzY29wZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5leHBvcnQgaW50ZXJmYWNlIFJ1bGUge1xuICBjb2RlOiBzdHJpbmc7XG4gIG1lc3NhZ2U6IHN0cmluZztcbiAgd2FybmluZz86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29uY3JldGVSdWxlPFQ+IGV4dGVuZHMgUnVsZSB7XG4gIGV2YWwobGludGVyOiBFdmFsdWF0aW9uPFQ+KTogdm9pZDtcbn1cblxuLyoqXG4gKiBBIHR5cGUgY29uc3RyYWludFxuICpcbiAqIEJlIHN1cGVyIGZsZXhpYmxlIGFib3V0IGhvdyB0eXBlcyBjYW4gYmUgcmVwcmVzZW50ZWQuIFVsdGltYXRlbHksIHdlIHdpbGxcbiAqIGNvbXBhcmUgd2hhdCB5b3UgZ2l2ZSB0byBhIFR5cGVSZWZlcmVuY2UsIGJlY2F1c2UgdGhhdCdzIHdoYXQncyBpbiB0aGUgSlNJSVxuICogUmVmbGVjdCBtb2RlbC4gSG93ZXZlciwgaWYgeW91IGFscmVhZHkgaGF2ZSBhIHJlYWwgVHlwZSwgb3IganVzdCBhIHN0cmluZyB0b1xuICogYSB1c2VyLWRlZmluZWQgdHlwZSwgdGhhdCdzIGZpbmUgdG9vLiBXZSdsbCBEbyBUaGUgUmlnaHQgVGhpbmcuXG4gKi9cbmV4cG9ydCB0eXBlIFR5cGVTcGVjaWZpZXIgPSByZWZsZWN0LlR5cGVSZWZlcmVuY2UgfCByZWZsZWN0LlR5cGUgfCBzdHJpbmc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWV0aG9kU2lnbmF0dXJlUGFyYW1ldGVyRXhwZWN0YXRpb24ge1xuICBuYW1lPzogc3RyaW5nO1xuICB0eXBlPzogVHlwZVNwZWNpZmllcjtcbiAgc3VidHlwZUFsbG93ZWQ/OiBib29sZWFuO1xuXG4gIC8qKiBzaG91bGQgdGhpcyBwYXJhbSBiZSBvcHRpb25hbD8gKi9cbiAgb3B0aW9uYWw/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1ldGhvZFNpZ25hdHVyZUV4cGVjdGF0aW9ucyB7XG4gIHBhcmFtZXRlcnM/OiBNZXRob2RTaWduYXR1cmVQYXJhbWV0ZXJFeHBlY3RhdGlvbltdO1xuICByZXR1cm5zPzogVHlwZVNwZWNpZmllcjtcbn1cblxuZXhwb3J0IGVudW0gRGlhZ25vc3RpY0xldmVsIHtcbiAgU2tpcHBlZCxcbiAgU3VjY2VzcyxcbiAgV2FybmluZyxcbiAgRXJyb3IsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGlhZ25vc3RpYyB7XG4gIGxldmVsOiBEaWFnbm9zdGljTGV2ZWw7XG4gIHJ1bGU6IFJ1bGU7XG4gIHNjb3BlOiBzdHJpbmc7XG4gIG1lc3NhZ2U6IHN0cmluZztcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdHlwZSBzcGVjaWZpZXIgdG8gYSBUeXBlUmVmZXJlbmNlXG4gKi9cbmZ1bmN0aW9uIHR5cGVSZWZlcmVuY2VGcm9tKHRzOiByZWZsZWN0LlR5cGVTeXN0ZW0sIHg6IFR5cGVTcGVjaWZpZXIpOiByZWZsZWN0LlR5cGVSZWZlcmVuY2Uge1xuICBpZiAoaXNUeXBlUmVmZXJlbmNlKHgpKSB7IHJldHVybiB4OyB9XG5cbiAgaWYgKHR5cGVvZiB4ID09PSAnc3RyaW5nJykge1xuICAgIGlmICh4LmluZGV4T2YoJy4nKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBuZXcgcmVmbGVjdC5UeXBlUmVmZXJlbmNlKHRzLCB7IHByaW1pdGl2ZTogeCBhcyBQcmltaXRpdmVUeXBlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IHJlZmxlY3QuVHlwZVJlZmVyZW5jZSh0cywgeyBmcW46IHggfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyByZWZsZWN0LlR5cGVSZWZlcmVuY2UodHMsIHgpO1xufVxuXG5mdW5jdGlvbiBpc1R5cGVSZWZlcmVuY2UoeDogYW55KTogeCBpcyByZWZsZWN0LlR5cGVSZWZlcmVuY2Uge1xuICByZXR1cm4geCBpbnN0YW5jZW9mIHJlZmxlY3QuVHlwZVJlZmVyZW5jZTtcbn1cbiJdfQ==