"use strict";
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Prompt = exports.PromptBase = void 0;
const jsiiDeprecationWarnings = require("../../.warnings.jsii.js");
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const bedrock = require("aws-cdk-lib/aws-bedrock");
const iam = require("aws-cdk-lib/aws-iam");
const core_1 = require("aws-cdk-lib/core");
const helpers_internal_1 = require("aws-cdk-lib/core/lib/helpers-internal");
const metadata_resource_1 = require("aws-cdk-lib/core/lib/metadata-resource");
const prop_injectable_1 = require("aws-cdk-lib/core/lib/prop-injectable");
const prompt_version_1 = require("./prompt-version");
const validation = require("../agents/validation-helpers");
/******************************************************************************
 *                        ABSTRACT BASE CLASS
 *****************************************************************************/
/**
 * Abstract base class for a Prompt.
 * Contains methods and attributes valid for Prompts either created with CDK or imported.
 */
class PromptBase extends core_1.Resource {
    static [JSII_RTTI_SYMBOL_1] = { fqn: "@aws-cdk/aws-bedrock-alpha.PromptBase", version: "2.235.0-alpha.0" };
    /**
     * Grant the given identity permissions to get the prompt.
     * [disable-awslint:no-grants]
     *
     * @param grantee - The IAM principal to grant permissions to
     * @default - Default grant configuration:
     * - actions: ['bedrock:GetPrompt']
     * - resourceArns: [this.promptArn]
     * @returns An IAM Grant object representing the granted permissions
     */
    grantGet(grantee) {
        return iam.Grant.addToPrincipal({
            grantee,
            resourceArns: [this.promptArn],
            actions: ['bedrock:GetPrompt'],
        });
    }
}
exports.PromptBase = PromptBase;
/******************************************************************************
 *                        NEW CONSTRUCT DEFINITION
 *****************************************************************************/
/**
 * Class to create (or import) a Prompt with CDK.
 *
 * Prompts are a specific set of inputs that guide Foundation Models (FMs) on Amazon Bedrock to
 * generate an appropriate response or output for a given task or instruction.
 * You can optimize the prompt for specific use cases and models.
 *
 * @cloudformationResource AWS::Bedrock::Prompt
 * @see https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-management.html
 */
let Prompt = (() => {
    let _classDecorators = [prop_injectable_1.propertyInjectable];
    let _classDescriptor;
    let _classExtraInitializers = [];
    let _classThis;
    let _classSuper = PromptBase;
    let _instanceExtraInitializers = [];
    let _createVersion_decorators;
    let _addVariant_decorators;
    var Prompt = class extends _classSuper {
        static { _classThis = this; }
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _createVersion_decorators = [(0, metadata_resource_1.MethodMetadata)()];
            _addVariant_decorators = [(0, metadata_resource_1.MethodMetadata)()];
            __esDecorate(this, null, _createVersion_decorators, { kind: "method", name: "createVersion", static: false, private: false, access: { has: obj => "createVersion" in obj, get: obj => obj.createVersion }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _addVariant_decorators, { kind: "method", name: "addVariant", static: false, private: false, access: { has: obj => "addVariant" in obj, get: obj => obj.addVariant }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
            Prompt = _classThis = _classDescriptor.value;
            if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static [JSII_RTTI_SYMBOL_1] = { fqn: "@aws-cdk/aws-bedrock-alpha.Prompt", version: "2.235.0-alpha.0" };
        /** Uniquely identifies this class. */
        static PROPERTY_INJECTION_ID = '@aws-cdk.aws-bedrock-alpha.Prompt';
        /******************************************************************************
         *                            IMPORT METHODS
         *****************************************************************************/
        /**
         * Creates a Prompt reference from an existing prompt's attributes.
         *
         * @param scope - The construct scope
         * @param id - Identifier of the construct
         * @param attrs - Attributes of the existing prompt
         * @default - For attrs.promptVersion: 'DRAFT' if no explicit version is provided
         * @returns An IPrompt reference to the existing prompt
         */
        static fromPromptAttributes(scope, id, attrs) {
            try {
                jsiiDeprecationWarnings._aws_cdk_aws_bedrock_alpha_PromptAttributes(attrs);
            }
            catch (error) {
                if (process.env.JSII_DEBUG !== "1" && error.name === "DeprecationError") {
                    Error.captureStackTrace(error, this.fromPromptAttributes);
                }
                throw error;
            }
            const formattedArn = core_1.Arn.split(attrs.promptArn, core_1.ArnFormat.SLASH_RESOURCE_NAME);
            class Import extends PromptBase {
                promptArn = attrs.promptArn;
                promptId = formattedArn.resourceName;
                promptVersion = attrs.promptVersion ?? 'DRAFT';
                kmsKey = attrs.kmsKey;
            }
            return new Import(scope, id);
        }
        /**
         * The maximum number of variants allowed for a prompt.
         * @internal
         */
        static MAX_VARIANTS = 1;
        /**
         * The name of the prompt.
         * @attribute
         */
        promptName = __runInitializers(this, _instanceExtraInitializers);
        /**
         * The KMS key that the prompt is encrypted with.
         */
        kmsKey;
        /**
         * The ARN of the prompt.
         * @attribute
         * @example "arn:aws:bedrock:us-east-1:123456789012:prompt/PROMPT12345"
         */
        promptArn;
        /**
         * The ID of the prompt.
         * @attribute
         * @example "PROMPT12345"
         */
        promptId;
        /**
         * The version of the prompt.
         * @attribute
         */
        promptVersion;
        /**
         * The variants of the prompt.
         */
        variants;
        /**
         * The description of the prompt.
         */
        description;
        /******************************************************************************
         *                            INTERNAL ONLY
         *****************************************************************************/
        /**
         * The computed hash of the prompt properties.
         * @internal
         */
        _hash;
        /**
         * L1 resource
         * @internal
         */
        __resource;
        /******************************************************************************
         *                            CONSTRUCTOR
         *****************************************************************************/
        constructor(scope, id, props) {
            super(scope, id);
            try {
                jsiiDeprecationWarnings._aws_cdk_aws_bedrock_alpha_PromptProps(props);
            }
            catch (error) {
                if (process.env.JSII_DEBUG !== "1" && error.name === "DeprecationError") {
                    Error.captureStackTrace(error, Prompt);
                }
                throw error;
            }
            // Enhanced CDK Analytics Telemetry
            (0, metadata_resource_1.addConstructMetadata)(this, props);
            // ------------------------------------------------------
            // Set properties and defaults
            // ------------------------------------------------------
            this.promptName = props.promptName;
            this.description = props.description;
            this.kmsKey = props.kmsKey;
            this.variants = props.variants ?? [];
            // ------------------------------------------------------
            // Validation
            // ------------------------------------------------------
            this.validatePromptDefault(props);
            this.node.addValidation({ validate: () => this.validatePromptName() });
            this.node.addValidation({ validate: () => this.validatePromptVariants() });
            this.node.addValidation({ validate: () => this.validateDescription() });
            this.node.addValidation({ validate: () => this.validateVariantNames() });
            // ------------------------------------------------------
            // CFN Props - With Lazy support
            // ------------------------------------------------------
            const cfnProps = {
                customerEncryptionKeyArn: this.kmsKey?.keyArn,
                defaultVariant: props.defaultVariant?.name,
                description: props.description,
                name: props.promptName,
                variants: core_1.Lazy.any({
                    produce: () => this.variants.map(variant => {
                        const variantConfig = {
                            name: variant.name,
                            templateType: variant.templateType,
                            templateConfiguration: variant.templateConfiguration._render(),
                        };
                        if (variant.modelId) {
                            variantConfig.modelId = variant.modelId;
                        }
                        if (variant.inferenceConfiguration) {
                            variantConfig.inferenceConfiguration = variant.inferenceConfiguration._render();
                        }
                        if (variant.genAiResource) {
                            variantConfig.genAiResource = variant.genAiResource._render();
                        }
                        return variantConfig;
                    }),
                }),
                tags: props.tags,
            };
            // Hash calculation useful for versioning
            this._hash = (0, helpers_internal_1.md5hash)(JSON.stringify(cfnProps));
            // ------------------------------------------------------
            // L1 Instantiation
            // ------------------------------------------------------
            this.__resource = new bedrock.CfnPrompt(this, 'Resource', cfnProps);
            this.promptArn = this.__resource.attrArn;
            this.promptId = this.__resource.attrId;
            this.promptVersion = this.__resource.attrVersion;
        }
        /******************************************************************************
         *                            VALIDATION METHODS
         *****************************************************************************/
        /**
         * Validates whether the prompt name is valid according to the specification.
         * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-bedrock-prompt.html#cfn-bedrock-prompt-name
         * @returns Array of validation error messages, empty if valid
         */
        validatePromptName() {
            const errors = [];
            // Use existing validation helper for pattern validation
            const patternErrors = validation.validateFieldPattern(this.promptName, 'promptName', /^([0-9a-zA-Z][_-]?){1,100}$/, 'Valid characters are a-z, A-Z, 0-9, _ (underscore) and - (hyphen). Must not begin with a hyphen and must be 1-100 characters long.');
            errors.push(...patternErrors);
            return errors;
        }
        /**
         * Validates whether the number of prompt variants is respected.
         * @returns Array of validation error messages, empty if valid
         */
        validatePromptVariants() {
            const errors = [];
            if (this.variants.length > Prompt.MAX_VARIANTS) {
                errors.push(`Too many variants specified. The maximum allowed is ${Prompt.MAX_VARIANTS}, but you have provided ${this.variants.length} variants.`);
            }
            return errors;
        }
        /**
         * Validates that if the prompt has a default, it was also added to the variants array
         * @param props - The properties set in the constructor
         */
        validatePromptDefault(props) {
            if (props.defaultVariant && !props.variants?.includes(props.defaultVariant)) {
                throw new core_1.ValidationError('The \'defaultVariant\' needs to be included in the \'variants\' array.', this);
            }
        }
        /**
         * Validates whether the description length is within the allowed limit.
         * @returns Array of validation error messages, empty if valid
         */
        validateDescription() {
            const errors = [];
            if (this.description && this.description.length > 200) {
                errors.push(`Description must be 200 characters or less, got ${this.description.length} characters.`);
            }
            return errors;
        }
        /**
         * Validates whether all variant names are unique.
         * @returns Array of validation error messages, empty if valid
         */
        validateVariantNames() {
            const errors = [];
            const names = this.variants.map(v => v.name);
            const duplicates = names.filter((name, index) => names.indexOf(name) !== index);
            if (duplicates.length > 0) {
                const uniqueDuplicates = [...new Set(duplicates)];
                errors.push(`Duplicate variant names found: ${uniqueDuplicates.join(', ')}. Each variant must have a unique name.`);
            }
            return errors;
        }
        /******************************************************************************
         *                            HELPER METHODS
         *****************************************************************************/
        /**
         * Creates a prompt version, a static snapshot of your prompt that can be
         * deployed to production.
         *
         * @param description - Optional description for the version
         * @default - No description provided
         * @returns A PromptVersion object containing the version details including ARN and version string
         */
        createVersion(description) {
            return new prompt_version_1.PromptVersion(this, `PromptVersion-${this._hash}`, {
                prompt: this,
                description,
            });
        }
        /**
         * Adds a prompt variant to the prompt.
         *
         * @param variant - The prompt variant to add
         * @throws ValidationError if adding the variant would exceed the maximum allowed variants
         */
        addVariant(variant) {
            try {
                jsiiDeprecationWarnings._aws_cdk_aws_bedrock_alpha_IPromptVariant(variant);
            }
            catch (error) {
                if (process.env.JSII_DEBUG !== "1" && error.name === "DeprecationError") {
                    Error.captureStackTrace(error, this.addVariant);
                }
                throw error;
            }
            validation.throwIfInvalid(this.validateVariantAddition, variant);
            this.variants.push(variant);
        }
        /**
         * Validates whether a variant can be added without exceeding limits.
         * @param variant - The variant to validate
         * @returns Array of validation error messages, empty if valid
         */
        validateVariantAddition = (variant) => {
            const errors = [];
            // Check if adding this variant would exceed the maximum
            if (this.variants.length >= Prompt.MAX_VARIANTS) {
                errors.push(`Cannot add variant to prompt '${this.promptName}'. Maximum of ${Prompt.MAX_VARIANTS} variants allowed, currently have ${this.variants.length}.`);
            }
            // Check for duplicate variant names
            if (this.variants.find(v => v.name === variant.name)) {
                errors.push(`Variant with name '${variant.name}' already exists.`);
            }
            return errors;
        };
        static {
            __runInitializers(_classThis, _classExtraInitializers);
        }
    };
    return Prompt = _classThis;
})();
exports.Prompt = Prompt;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvbXB0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicHJvbXB0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG1EQUFtRDtBQUNuRCwyQ0FBMkM7QUFFM0MsMkNBQThGO0FBQzlGLDRFQUFnRTtBQUNoRSw4RUFBOEY7QUFDOUYsMEVBQTBFO0FBSzFFLHFEQUFpRDtBQUNqRCwyREFBMkQ7QUF5QzNEOzsrRUFFK0U7QUFDL0U7OztHQUdHO0FBQ0gsTUFBc0IsVUFBVyxTQUFRLGVBQVE7O0lBTS9DOzs7Ozs7Ozs7T0FTRztJQUNJLFFBQVEsQ0FBQyxPQUF1QjtRQUNyQyxPQUFPLEdBQUcsQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDO1lBQzlCLE9BQU87WUFDUCxZQUFZLEVBQUUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDO1lBQzlCLE9BQU8sRUFBRSxDQUFDLG1CQUFtQixDQUFDO1NBQy9CLENBQUMsQ0FBQztLQUNKOztBQXRCSCxnQ0F1QkM7QUFrRkQ7OytFQUUrRTtBQUMvRTs7Ozs7Ozs7O0dBU0c7SUFFVSxNQUFNOzRCQURsQixvQ0FBa0I7Ozs7c0JBQ1MsVUFBVTs7OztzQkFBbEIsU0FBUSxXQUFVOzs7O3lDQWtRbkMsSUFBQSxrQ0FBYyxHQUFFO3NDQWNoQixJQUFBLGtDQUFjLEdBQUU7WUFiakIsMExBQU8sYUFBYSw2REFLbkI7WUFTRCxpTEFBTyxVQUFVLDZEQUdoQjtZQXBSSCw2S0E0U0M7Ozs7O1FBM1NDLHNDQUFzQztRQUMvQixNQUFNLENBQVUscUJBQXFCLEdBQVcsbUNBQW1DLENBQUM7UUFFM0Y7O3VGQUUrRTtRQUMvRTs7Ozs7Ozs7V0FRRztRQUNJLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxLQUFnQixFQUFFLEVBQVUsRUFBRSxLQUF1Qjs7Ozs7Ozs7OztZQUN0RixNQUFNLFlBQVksR0FBRyxVQUFHLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxTQUFT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QUFDLHVCQUF1QixFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQ2pFLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQzdCO1FBRUQ7Ozs7V0FJRztRQUNLLHVCQUF1QixHQUFHLENBQUMsT0FBdUIsRUFBWSxFQUFFO1lBQ3RFLE1BQU0sTUFBTSxHQUFhLEVBQUUsQ0FBQztZQUU1Qix3REFBd0Q7WUFDeEQsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sSUFBSSxNQUFNLENBQUMsWUFBWSxFQUFFLENBQUM7Z0JBQ2hELE1BQU0sQ0FBQyxJQUFJLENBQ1QsaUNBQWlDLElBQUksQ0FBQyxVQUFVLGlCQUFpQixNQUFNLENBQUMsWUFBWSxxQ0FBcUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FDakosQ0FBQztZQUNKLENBQUM7WUFFRCxvQ0FBb0M7WUFDcEMsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7Z0JBQ3JELE1BQU0sQ0FBQyxJQUFJLENBQUMsc0JBQXNCLE9BQU8sQ0FBQyxJQUFJLG1CQUFtQixDQUFDLENBQUM7WUFDckUsQ0FBQztZQUVELE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUMsQ0FBQzs7WUEzU1MsdURBQU07Ozs7O0FBQU4sd0JBQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBiZWRyb2NrIGZyb20gJ2F3cy1jZGstbGliL2F3cy1iZWRyb2NrJztcbmltcG9ydCAqIGFzIGlhbSBmcm9tICdhd3MtY2RrLWxpYi9hd3MtaWFtJztcbmltcG9ydCAqIGFzIGttcyBmcm9tICdhd3MtY2RrLWxpYi9hd3Mta21zJztcbmltcG9ydCB7IEFybiwgQXJuRm9ybWF0LCBJUmVzb3VyY2UsIExhenksIFJlc291cmNlLCBWYWxpZGF0aW9uRXJyb3IgfSBmcm9tICdhd3MtY2RrLWxpYi9jb3JlJztcbmltcG9ydCB7IG1kNWhhc2ggfSBmcm9tICdhd3MtY2RrLWxpYi9jb3JlL2xpYi9oZWxwZXJzLWludGVybmFsJztcbmltcG9ydCB7IGFkZENvbnN0cnVjdE1ldGFkYXRhLCBNZXRob2RNZXRhZGF0YSB9IGZyb20gJ2F3cy1jZGstbGliL2NvcmUvbGliL21ldGFkYXRhLXJlc291cmNlJztcbmltcG9ydCB7IHByb3BlcnR5SW5qZWN0YWJsZSB9IGZyb20gJ2F3cy1jZGstbGliL2NvcmUvbGliL3Byb3AtaW5qZWN0YWJsZSc7XG5pbXBvcnQgeyBDb25zdHJ1Y3QgfSBmcm9tICdjb25zdHJ1Y3RzJztcblxuLy8gSW50ZXJuYWwgTGlic1xuaW1wb3J0IHsgSVByb21wdFZhcmlhbnQgfSBmcm9tICcuL3Byb21wdC12YXJpYW50JztcbmltcG9ydCB7IFByb21wdFZlcnNpb24gfSBmcm9tICcuL3Byb21wdC12ZXJzaW9uJztcbmltcG9ydCAqIGFzIHZhbGlkYXRpb24gZnJvbSAnLi4vYWdlbnRzL3ZhbGlkYXRpb24taGVscGVycyc7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ09NTU9OXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKipcbiAqIFJlcHJlc2VudHMgYSBQcm9tcHQsIGVpdGhlciBjcmVhdGVkIHdpdGggQ0RLIG9yIGltcG9ydGVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElQcm9tcHQgZXh0ZW5kcyBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogVGhlIEFSTiBvZiB0aGUgcHJvbXB0LlxuICAgKiBAYXR0cmlidXRlXG4gICAqIEBleGFtcGxlIFwiYXJuOmF3czpiZWRyb2NrOnVzLWVhc3QtMToxMjM0NTY3ODkwMTI6cHJvbXB0L1BST01QVDEyMzQ1XCJcbiAgICovXG4gIHJlYWRvbmx5IHByb21wdEFybjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHByb21wdC5cbiAgICogQGF0dHJpYnV0ZVxuICAgKiBAZXhhbXBsZSBcIlBST01QVDEyMzQ1XCJcbiAgICovXG4gIHJlYWRvbmx5IHByb21wdElkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBwcm9tcHQuXG4gICAqIEBhdHRyaWJ1dGVcbiAgICogQGRlZmF1bHQgXCJEUkFGVFwiXG4gICAqL1xuICByZWFkb25seSBwcm9tcHRWZXJzaW9uOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIEtNUyBlbmNyeXB0aW9uIGtleSBhc3NvY2lhdGVkIHdpdGggdGhpcyBwcm9tcHQuXG4gICAqL1xuICByZWFkb25seSBrbXNLZXk/OiBrbXMuSUtleTtcblxuICAvKipcbiAgICogR3JhbnQgdGhlIGdpdmVuIGlkZW50aXR5IHBlcm1pc3Npb25zIHRvIGdldCB0aGUgcHJvbXB0LlxuICAgKi9cbiAgZ3JhbnRHZXQoZ3JhbnRlZTogaWFtLklHcmFudGFibGUpOiBpYW0uR3JhbnQ7XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgICAgICAgICAgICAgICAgICAgICAgQUJTVFJBQ1QgQkFTRSBDTEFTU1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBhIFByb21wdC5cbiAqIENvbnRhaW5zIG1ldGhvZHMgYW5kIGF0dHJpYnV0ZXMgdmFsaWQgZm9yIFByb21wdHMgZWl0aGVyIGNyZWF0ZWQgd2l0aCBDREsgb3IgaW1wb3J0ZWQuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBQcm9tcHRCYXNlIGV4dGVuZHMgUmVzb3VyY2UgaW1wbGVtZW50cyBJUHJvbXB0IHtcbiAgcHVibGljIGFic3RyYWN0IHJlYWRvbmx5IHByb21wdEFybjogc3RyaW5nO1xuICBwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgcHJvbXB0SWQ6IHN0cmluZztcbiAgcHVibGljIGFic3RyYWN0IHJlYWRvbmx5IGttc0tleT86IGttcy5JS2V5O1xuICBwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgcHJvbXB0VmVyc2lvbjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBHcmFudCB0aGUgZ2l2ZW4gaWRlbnRpdHkgcGVybWlzc2lvbnMgdG8gZ2V0IHRoZSBwcm9tcHQuXG4gICAqIFtkaXNhYmxlLWF3c2xpbnQ6bm8tZ3JhbnRzXVxuICAgKlxuICAgKiBAcGFyYW0gZ3JhbnRlZSAtIFRoZSBJQU0gcHJpbmNpcGFsIHRvIGdyYW50IHBlcm1pc3Npb25zIHRvXG4gICAqIEBkZWZhdWx0IC0gRGVmYXVsdCBncmFudCBjb25maWd1cmF0aW9uOlxuICAgKiAtIGFjdGlvbnM6IFsnYmVkcm9jazpHZXRQcm9tcHQnXVxuICAgKiAtIHJlc291cmNlQXJuczogW3RoaXMucHJvbXB0QXJuXVxuICAgKiBAcmV0dXJucyBBbiBJQU0gR3JhbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgZ3JhbnRlZCBwZXJtaXNzaW9uc1xuICAgKi9cbiAgcHVibGljIGdyYW50R2V0KGdyYW50ZWU6IGlhbS5JR3JhbnRhYmxlKTogaWFtLkdyYW50IHtcbiAgICByZXR1cm4gaWFtLkdyYW50LmFkZFRvUHJpbmNpcGFsKHtcbiAgICAgIGdyYW50ZWUsXG4gICAgICByZXNvdXJjZUFybnM6IFt0aGlzLnByb21wdEFybl0sXG4gICAgICBhY3Rpb25zOiBbJ2JlZHJvY2s6R2V0UHJvbXB0J10sXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICAgICAgICAgICAgICAgICAgICAgICBQUk9QUyBGT1IgTkVXIENPTlNUUlVDVFxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqXG4gKiBQcm9wZXJ0aWVzIGZvciBjcmVhdGluZyBhIENESyBtYW5hZ2VkIEJlZHJvY2sgUHJvbXB0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFByb21wdFByb3BzIHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBwcm9tcHQuXG4gICAqIFRoaXMgd2lsbCBiZSB1c2VkIGFzIHRoZSBwaHlzaWNhbCBuYW1lIG9mIHRoZSBwcm9tcHQuXG4gICAqIEFsbG93ZWQgUGF0dGVybjogXihbMC05YS16QS1aXVtfLV0/KXsxLDEwMH0kXG4gICAqL1xuICByZWFkb25seSBwcm9tcHROYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgZGVzY3JpcHRpb24gb2Ygd2hhdCB0aGUgcHJvbXB0IGRvZXMuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQuXG4gICAqIE1heGltdW0gTGVuZ3RoOiAyMDBcbiAgICovXG4gIHJlYWRvbmx5IGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgS01TIGtleSB0aGF0IHRoZSBwcm9tcHQgaXMgZW5jcnlwdGVkIHdpdGguXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gQVdTIG93bmVkIGFuZCBtYW5hZ2VkIGtleS5cbiAgICovXG4gIHJlYWRvbmx5IGttc0tleT86IGttcy5JS2V5O1xuXG4gIC8qKlxuICAgKiBUaGUgUHJvbXB0IFZhcmlhbnQgdGhhdCB3aWxsIGJlIHVzZWQgYnkgZGVmYXVsdC5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBObyBkZWZhdWx0IHZhcmlhbnQgcHJvdmlkZWQuXG4gICAqL1xuICByZWFkb25seSBkZWZhdWx0VmFyaWFudD86IElQcm9tcHRWYXJpYW50O1xuXG4gIC8qKlxuICAgKiBUaGUgdmFyaWFudHMgb2YgeW91ciBwcm9tcHQuIFZhcmlhbnRzIGNhbiB1c2UgZGlmZmVyZW50IG1lc3NhZ2VzLCBtb2RlbHMsXG4gICAqIG9yIGNvbmZpZ3VyYXRpb25zIHNvIHRoYXQgeW91IGNhbiBjb21wYXJlIHRoZWlyIG91dHB1dHMgdG8gZGVjaWRlIHRoZSBiZXN0XG4gICAqIHZhcmlhbnQgZm9yIHlvdXIgdXNlIGNhc2UuIE1heGltdW0gb2YgMSB2YXJpYW50cy5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBObyBhZGRpdGlvbmFsIHZhcmlhbnRzIHByb3ZpZGVkLlxuICAgKi9cbiAgcmVhZG9ubHkgdmFyaWFudHM/OiBJUHJvbXB0VmFyaWFudFtdO1xuXG4gIC8qKlxuICAgKiBUYWdzIHRvIGFwcGx5IHRvIHRoZSBwcm9tcHQuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm8gdGFncyBhcHBsaWVkLlxuICAgKi9cbiAgcmVhZG9ubHkgdGFncz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgICAgICAgICAgICAgICAgICAgIEFUVFJTIEZPUiBJTVBPUlRFRCBDT05TVFJVQ1RcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKlxuICogQXR0cmlidXRlcyBmb3Igc3BlY2lmeWluZyBhbiBpbXBvcnRlZCBCZWRyb2NrIFByb21wdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcm9tcHRBdHRyaWJ1dGVzIHtcbiAgLyoqXG4gICAqIFRoZSBBUk4gb2YgdGhlIHByb21wdC5cbiAgICogQGF0dHJpYnV0ZVxuICAgKiBAZXhhbXBsZSBcImFybjphd3M6YmVkcm9jazp1cy1lYXN0LTE6MTIzNDU2Nzg5MDEyOnByb21wdC9QUk9NUFQxMjM0NVwiXG4gICAqL1xuICByZWFkb25seSBwcm9tcHRBcm46IHN0cmluZztcblxuICAvKipcbiAgICogT3B0aW9uYWwgS01TIGVuY3J5cHRpb24ga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGlzIHByb21wdC5cbiAgICogQGRlZmF1bHQgdW5kZWZpbmVkIC0gQW4gQVdTIG1hbmFnZWQga2V5IGlzIHVzZWRcbiAgICovXG4gIHJlYWRvbmx5IGttc0tleT86IGttcy5JS2V5O1xuXG4gIC8qKlxuICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgcHJvbXB0LlxuICAgKiBAZGVmYXVsdCBcIkRSQUZUXCJcbiAgICovXG4gIHJlYWRvbmx5IHByb21wdFZlcnNpb24/OiBzdHJpbmc7XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgICAgICAgICAgICAgICAgICAgICAgTkVXIENPTlNUUlVDVCBERUZJTklUSU9OXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKipcbiAqIENsYXNzIHRvIGNyZWF0ZSAob3IgaW1wb3J0KSBhIFByb21wdCB3aXRoIENESy5cbiAqXG4gKiBQcm9tcHRzIGFyZSBhIHNwZWNpZmljIHNldCBvZiBpbnB1dHMgdGhhdCBndWlkZSBGb3VuZGF0aW9uIE1vZGVscyAoRk1zKSBvbiBBbWF6b24gQmVkcm9jayB0b1xuICogZ2VuZXJhdGUgYW4gYXBwcm9wcmlhdGUgcmVzcG9uc2Ugb3Igb3V0cHV0IGZvciBhIGdpdmVuIHRhc2sgb3IgaW5zdHJ1Y3Rpb24uXG4gKiBZb3UgY2FuIG9wdGltaXplIHRoZSBwcm9tcHQgZm9yIHNwZWNpZmljIHVzZSBjYXNlcyBhbmQgbW9kZWxzLlxuICpcbiAqIEBjbG91ZGZvcm1hdGlvblJlc291cmNlIEFXUzo6QmVkcm9jazo6UHJvbXB0XG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9iZWRyb2NrL2xhdGVzdC91c2VyZ3VpZGUvcHJvbXB0LW1hbmFnZW1lbnQuaHRtbFxuICovXG5AcHJvcGVydHlJbmplY3RhYmxlXG5leHBvcnQgY2xhc3MgUHJvbXB0IGV4dGVuZHMgUHJvbXB0QmFzZSBpbXBsZW1lbnRzIElQcm9tcHQge1xuICAvKiogVW5pcXVlbHkgaWRlbnRpZmllcyB0aGlzIGNsYXNzLiAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFBST1BFUlRZX0lOSkVDVElPTl9JRDogc3RyaW5nID0gJ0Bhd3MtY2RrLmF3cy1iZWRyb2NrLWFscGhhLlByb21wdCc7XG5cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBJTVBPUlQgTUVUSE9EU1xuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUHJvbXB0IHJlZmVyZW5jZSBmcm9tIGFuIGV4aXN0aW5nIHByb21wdCdzIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSBzY29wZSAtIFRoZSBjb25zdHJ1Y3Qgc2NvcGVcbiAgICogQHBhcmFtIGlkIC0gSWRlbnRpZmllciBvZiB0aGUgY29uc3RydWN0XG4gICAqIEBwYXJhbSBhdHRycyAtIEF0dHJpYnV0ZXMgb2YgdGhlIGV4aXN0aW5nIHByb21wdFxuICAgKiBAZGVmYXVsdCAtIEZvciBhdHRycy5wcm9tcHRWZXJzaW9uOiAnRFJBRlQnIGlmIG5vIGV4cGxpY2l0IHZlcnNpb24gaXMgcHJvdmlkZWRcbiAgICogQHJldHVybnMgQW4gSVByb21wdCByZWZlcmVuY2UgdG8gdGhlIGV4aXN0aW5nIHByb21wdFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tUHJvbXB0QXR0cmlidXRlcyhzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBhdHRyczogUHJvbXB0QXR0cmlidXRlcyk6IElQcm9tcHQge1xuICAgIGNvbnN0IGZvcm1hdHRlZEFybiA9IEFybi5zcGxpdChhdHRycy5wcm9tcHRBcm4sIEFybkZvcm1hdC5TTEFTSF9SRVNPVVJDRV9OQU1FKTtcblxuICAgIGNsYXNzIEltcG9ydCBleHRlbmRzIFByb21wdEJhc2Uge1xuICAgICAgcHVibGljIHJlYWRvbmx5IHByb21wdEFybiA9IGF0dHJzLnByb21wdEFybjtcbiAgICAgIHB1YmxpYyByZWFkb25seSBwcm9tcHRJZCA9IGZvcm1hdHRlZEFybi5yZXNvdXJjZU5hbWUhO1xuICAgICAgcHVibGljIHJlYWRvbmx5IHByb21wdFZlcnNpb24gPSBhdHRycy5wcm9tcHRWZXJzaW9uID8/ICdEUkFGVCc7XG4gICAgICBwdWJsaWMgcmVhZG9ubHkga21zS2V5ID0gYXR0cnMua21zS2V5O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSW1wb3J0KHNjb3BlLCBpZCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHZhcmlhbnRzIGFsbG93ZWQgZm9yIGEgcHJvbXB0LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IE1BWF9WQVJJQU5UUyA9IDE7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBwcm9tcHQuXG4gICAqIEBhdHRyaWJ1dGVcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBwcm9tcHROYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBLTVMga2V5IHRoYXQgdGhlIHByb21wdCBpcyBlbmNyeXB0ZWQgd2l0aC5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBrbXNLZXk/OiBrbXMuSUtleTtcblxuICAvKipcbiAgICogVGhlIEFSTiBvZiB0aGUgcHJvbXB0LlxuICAgKiBAYXR0cmlidXRlXG4gICAqIEBleGFtcGxlIFwiYXJuOmF3czpiZWRyb2NrOnVzLWVhc3QtMToxMjM0NTY3ODkwMTI6cHJvbXB0L1BST01QVDEyMzQ1XCJcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBwcm9tcHRBcm46IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBwcm9tcHQuXG4gICAqIEBhdHRyaWJ1dGVcbiAgICogQGV4YW1wbGUgXCJQUk9NUFQxMjM0NVwiXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgcHJvbXB0SWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHZlcnNpb24gb2YgdGhlIHByb21wdC5cbiAgICogQGF0dHJpYnV0ZVxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHByb21wdFZlcnNpb246IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHZhcmlhbnRzIG9mIHRoZSBwcm9tcHQuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgdmFyaWFudHM6IElQcm9tcHRWYXJpYW50W107XG5cbiAgLyoqXG4gICAqIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgcHJvbXB0LlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgSU5URVJOQUwgT05MWVxuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qKlxuICAgKiBUaGUgY29tcHV0ZWQgaGFzaCBvZiB0aGUgcHJvbXB0IHByb3BlcnRpZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9oYXNoOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEwxIHJlc291cmNlXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBfX3Jlc291cmNlOiBiZWRyb2NrLkNmblByb21wdDtcblxuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIENPTlNUUlVDVE9SXG4gICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM6IFByb21wdFByb3BzKSB7XG4gICAgc3VwZXIoc2NvcGUsIGlkKTtcbiAgICAvLyBFbmhhbmNlZCBDREsgQW5hbHl0aWNzIFRlbGVtZXRyeVxuICAgIGFkZENvbnN0cnVjdE1ldGFkYXRhKHRoaXMsIHByb3BzKTtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFNldCBwcm9wZXJ0aWVzIGFuZCBkZWZhdWx0c1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHRoaXMucHJvbXB0TmFtZSA9IHByb3BzLnByb21wdE5hbWU7XG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IHByb3BzLmRlc2NyaXB0aW9uO1xuICAgIHRoaXMua21zS2V5ID0gcHJvcHMua21zS2V5O1xuICAgIHRoaXMudmFyaWFudHMgPSBwcm9wcy52YXJpYW50cyA/PyBbXTtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFZhbGlkYXRpb25cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB0aGlzLnZhbGlkYXRlUHJvbXB0RGVmYXVsdChwcm9wcyk7XG4gICAgdGhpcy5ub2RlLmFkZFZhbGlkYXRpb24oeyB2YWxpZGF0ZTogKCkgPT4gdGhpcy52YWxpZGF0ZVByb21wdE5hbWUoKSB9KTtcbiAgICB0aGlzLm5vZGUuYWRkVmFsaWRhdGlvbih7IHZhbGlkYXRlOiAoKSA9PiB0aGlzLnZhbGlkYXRlUHJvbXB0VmFyaWFudHMoKSB9KTtcbiAgICB0aGlzLm5vZGUuYWRkVmFsaWRhdGlvbih7IHZhbGlkYXRlOiAoKSA9PiB0aGlzLnZhbGlkYXRlRGVzY3JpcHRpb24oKSB9KTtcbiAgICB0aGlzLm5vZGUuYWRkVmFsaWRhdGlvbih7IHZhbGlkYXRlOiAoKSA9PiB0aGlzLnZhbGlkYXRlVmFyaWFudE5hbWVzKCkgfSk7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBDRk4gUHJvcHMgLSBXaXRoIExhenkgc3VwcG9ydFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGNvbnN0IGNmblByb3BzOiBiZWRyb2NrLkNmblByb21wdFByb3BzID0ge1xuICAgICAgY3VzdG9tZXJFbmNyeXB0aW9uS2V5QXJuOiB0aGlzLmttc0tleT8ua2V5QXJuLFxuICAgICAgZGVmYXVsdFZhcmlhbnQ6IHByb3BzLmRlZmF1bHRWYXJpYW50Py5uYW1lLFxuICAgICAgZGVzY3JpcHRpb246IHByb3BzLmRlc2NyaXB0aW9uLFxuICAgICAgbmFtZTogcHJvcHMucHJvbXB0TmFtZSxcbiAgICAgIHZhcmlhbnRzOiBMYXp5LmFueSh7XG4gICAgICAgIHByb2R1Y2U6ICgpID0+IHRoaXMudmFyaWFudHMubWFwKHZhcmlhbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IHZhcmlhbnRDb25maWc6IGFueSA9IHtcbiAgICAgICAgICAgIG5hbWU6IHZhcmlhbnQubmFtZSxcbiAgICAgICAgICAgIHRlbXBsYXRlVHlwZTogdmFyaWFudC50ZW1wbGF0ZVR5cGUsXG4gICAgICAgICAgICB0ZW1wbGF0ZUNvbmZpZ3VyYXRpb246IHZhcmlhbnQudGVtcGxhdGVDb25maWd1cmF0aW9uLl9yZW5kZXIoKSxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHZhcmlhbnQubW9kZWxJZCkge1xuICAgICAgICAgICAgdmFyaWFudENvbmZpZy5tb2RlbElkID0gdmFyaWFudC5tb2RlbElkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YXJpYW50LmluZmVyZW5jZUNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgIHZhcmlhbnRDb25maWcuaW5mZXJlbmNlQ29uZmlndXJhdGlvbiA9IHZhcmlhbnQuaW5mZXJlbmNlQ29uZmlndXJhdGlvbi5fcmVuZGVyKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhcmlhbnQuZ2VuQWlSZXNvdXJjZSkge1xuICAgICAgICAgICAgdmFyaWFudENvbmZpZy5nZW5BaVJlc291cmNlID0gdmFyaWFudC5nZW5BaVJlc291cmNlLl9yZW5kZXIoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdmFyaWFudENvbmZpZztcbiAgICAgICAgfSksXG4gICAgICB9KSxcbiAgICAgIHRhZ3M6IHByb3BzLnRhZ3MsXG4gICAgfTtcblxuICAgIC8vIEhhc2ggY2FsY3VsYXRpb24gdXNlZnVsIGZvciB2ZXJzaW9uaW5nXG4gICAgdGhpcy5faGFzaCA9IG1kNWhhc2goSlNPTi5zdHJpbmdpZnkoY2ZuUHJvcHMpKTtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEwxIEluc3RhbnRpYXRpb25cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB0aGlzLl9fcmVzb3VyY2UgPSBuZXcgYmVkcm9jay5DZm5Qcm9tcHQodGhpcywgJ1Jlc291cmNlJywgY2ZuUHJvcHMpO1xuXG4gICAgdGhpcy5wcm9tcHRBcm4gPSB0aGlzLl9fcmVzb3VyY2UuYXR0ckFybjtcbiAgICB0aGlzLnByb21wdElkID0gdGhpcy5fX3Jlc291cmNlLmF0dHJJZDtcbiAgICB0aGlzLnByb21wdFZlcnNpb24gPSB0aGlzLl9fcmVzb3VyY2UuYXR0clZlcnNpb247XG4gIH1cblxuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZBTElEQVRJT04gTUVUSE9EU1xuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgd2hldGhlciB0aGUgcHJvbXB0IG5hbWUgaXMgdmFsaWQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpY2F0aW9uLlxuICAgKiBAc2VlIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BV1NDbG91ZEZvcm1hdGlvbi9sYXRlc3QvVXNlckd1aWRlL2F3cy1yZXNvdXJjZS1iZWRyb2NrLXByb21wdC5odG1sI2Nmbi1iZWRyb2NrLXByb21wdC1uYW1lXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIHZhbGlkYXRpb24gZXJyb3IgbWVzc2FnZXMsIGVtcHR5IGlmIHZhbGlkXG4gICAqL1xuICBwcml2YXRlIHZhbGlkYXRlUHJvbXB0TmFtZSgpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgLy8gVXNlIGV4aXN0aW5nIHZhbGlkYXRpb24gaGVscGVyIGZvciBwYXR0ZXJuIHZhbGlkYXRpb25cbiAgICBjb25zdCBwYXR0ZXJuRXJyb3JzID0gdmFsaWRhdGlvbi52YWxpZGF0ZUZpZWxkUGF0dGVybihcbiAgICAgIHRoaXMucHJvbXB0TmFtZSxcbiAgICAgICdwcm9tcHROYW1lJyxcbiAgICAgIC9eKFswLTlhLXpBLVpdW18tXT8pezEsMTAwfSQvLFxuICAgICAgJ1ZhbGlkIGNoYXJhY3RlcnMgYXJlIGEteiwgQS1aLCAwLTksIF8gKHVuZGVyc2NvcmUpIGFuZCAtIChoeXBoZW4pLiBNdXN0IG5vdCBiZWdpbiB3aXRoIGEgaHlwaGVuIGFuZCBtdXN0IGJlIDEtMTAwIGNoYXJhY3RlcnMgbG9uZy4nLFxuICAgICk7XG5cbiAgICBlcnJvcnMucHVzaCguLi5wYXR0ZXJuRXJyb3JzKTtcbiAgICByZXR1cm4gZXJyb3JzO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB3aGV0aGVyIHRoZSBudW1iZXIgb2YgcHJvbXB0IHZhcmlhbnRzIGlzIHJlc3BlY3RlZC5cbiAgICogQHJldHVybnMgQXJyYXkgb2YgdmFsaWRhdGlvbiBlcnJvciBtZXNzYWdlcywgZW1wdHkgaWYgdmFsaWRcbiAgICovXG4gIHByaXZhdGUgdmFsaWRhdGVQcm9tcHRWYXJpYW50cygpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgaWYgKHRoaXMudmFyaWFudHMubGVuZ3RoID4gUHJvbXB0Lk1BWF9WQVJJQU5UUykge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgIGBUb28gbWFueSB2YXJpYW50cyBzcGVjaWZpZWQuIFRoZSBtYXhpbXVtIGFsbG93ZWQgaXMgJHtQcm9tcHQuTUFYX1ZBUklBTlRTfSwgYnV0IHlvdSBoYXZlIHByb3ZpZGVkICR7dGhpcy52YXJpYW50cy5sZW5ndGh9IHZhcmlhbnRzLmAsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBlcnJvcnM7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoYXQgaWYgdGhlIHByb21wdCBoYXMgYSBkZWZhdWx0LCBpdCB3YXMgYWxzbyBhZGRlZCB0byB0aGUgdmFyaWFudHMgYXJyYXlcbiAgICogQHBhcmFtIHByb3BzIC0gVGhlIHByb3BlcnRpZXMgc2V0IGluIHRoZSBjb25zdHJ1Y3RvclxuICAgKi9cbiAgcHJpdmF0ZSB2YWxpZGF0ZVByb21wdERlZmF1bHQocHJvcHM6IFByb21wdFByb3BzKSB7XG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYXJpYW50ICYmICFwcm9wcy52YXJpYW50cz8uaW5jbHVkZXMocHJvcHMuZGVmYXVsdFZhcmlhbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKCdUaGUgXFwnZGVmYXVsdFZhcmlhbnRcXCcgbmVlZHMgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIFxcJ3ZhcmlhbnRzXFwnIGFycmF5LicsIHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgd2hldGhlciB0aGUgZGVzY3JpcHRpb24gbGVuZ3RoIGlzIHdpdGhpbiB0aGUgYWxsb3dlZCBsaW1pdC5cbiAgICogQHJldHVybnMgQXJyYXkgb2YgdmFsaWRhdGlvbiBlcnJvciBtZXNzYWdlcywgZW1wdHkgaWYgdmFsaWRcbiAgICovXG4gIHByaXZhdGUgdmFsaWRhdGVEZXNjcmlwdGlvbigpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgaWYgKHRoaXMuZGVzY3JpcHRpb24gJiYgdGhpcy5kZXNjcmlwdGlvbi5sZW5ndGggPiAyMDApIHtcbiAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICBgRGVzY3JpcHRpb24gbXVzdCBiZSAyMDAgY2hhcmFjdGVycyBvciBsZXNzLCBnb3QgJHt0aGlzLmRlc2NyaXB0aW9uLmxlbmd0aH0gY2hhcmFjdGVycy5gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXJyb3JzO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB3aGV0aGVyIGFsbCB2YXJpYW50IG5hbWVzIGFyZSB1bmlxdWUuXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIHZhbGlkYXRpb24gZXJyb3IgbWVzc2FnZXMsIGVtcHR5IGlmIHZhbGlkXG4gICAqL1xuICBwcml2YXRlIHZhbGlkYXRlVmFyaWFudE5hbWVzKCk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgbmFtZXMgPSB0aGlzLnZhcmlhbnRzLm1hcCh2ID0+IHYubmFtZSk7XG4gICAgY29uc3QgZHVwbGljYXRlcyA9IG5hbWVzLmZpbHRlcigobmFtZSwgaW5kZXgpID0+IG5hbWVzLmluZGV4T2YobmFtZSkgIT09IGluZGV4KTtcblxuICAgIGlmIChkdXBsaWNhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHVuaXF1ZUR1cGxpY2F0ZXMgPSBbLi4ubmV3IFNldChkdXBsaWNhdGVzKV07XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgYER1cGxpY2F0ZSB2YXJpYW50IG5hbWVzIGZvdW5kOiAke3VuaXF1ZUR1cGxpY2F0ZXMuam9pbignLCAnKX0uIEVhY2ggdmFyaWFudCBtdXN0IGhhdmUgYSB1bmlxdWUgbmFtZS5gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXJyb3JzO1xuICB9XG5cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBIRUxQRVIgTUVUSE9EU1xuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcHJvbXB0IHZlcnNpb24sIGEgc3RhdGljIHNuYXBzaG90IG9mIHlvdXIgcHJvbXB0IHRoYXQgY2FuIGJlXG4gICAqIGRlcGxveWVkIHRvIHByb2R1Y3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBkZXNjcmlwdGlvbiAtIE9wdGlvbmFsIGRlc2NyaXB0aW9uIGZvciB0aGUgdmVyc2lvblxuICAgKiBAZGVmYXVsdCAtIE5vIGRlc2NyaXB0aW9uIHByb3ZpZGVkXG4gICAqIEByZXR1cm5zIEEgUHJvbXB0VmVyc2lvbiBvYmplY3QgY29udGFpbmluZyB0aGUgdmVyc2lvbiBkZXRhaWxzIGluY2x1ZGluZyBBUk4gYW5kIHZlcnNpb24gc3RyaW5nXG4gICAqL1xuICBATWV0aG9kTWV0YWRhdGEoKVxuICBwdWJsaWMgY3JlYXRlVmVyc2lvbihkZXNjcmlwdGlvbj86IHN0cmluZyk6IFByb21wdFZlcnNpb24ge1xuICAgIHJldHVybiBuZXcgUHJvbXB0VmVyc2lvbih0aGlzLCBgUHJvbXB0VmVyc2lvbi0ke3RoaXMuX2hhc2h9YCwge1xuICAgICAgcHJvbXB0OiB0aGlzLFxuICAgICAgZGVzY3JpcHRpb24sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIHByb21wdCB2YXJpYW50IHRvIHRoZSBwcm9tcHQuXG4gICAqXG4gICAqIEBwYXJhbSB2YXJpYW50IC0gVGhlIHByb21wdCB2YXJpYW50IHRvIGFkZFxuICAgKiBAdGhyb3dzIFZhbGlkYXRpb25FcnJvciBpZiBhZGRpbmcgdGhlIHZhcmlhbnQgd291bGQgZXhjZWVkIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFyaWFudHNcbiAgICovXG4gIEBNZXRob2RNZXRhZGF0YSgpXG4gIHB1YmxpYyBhZGRWYXJpYW50KHZhcmlhbnQ6IElQcm9tcHRWYXJpYW50KTogdm9pZCB7XG4gICAgdmFsaWRhdGlvbi50aHJvd0lmSW52YWxpZCh0aGlzLnZhbGlkYXRlVmFyaWFudEFkZGl0aW9uLCB2YXJpYW50KTtcbiAgICB0aGlzLnZhcmlhbnRzLnB1c2godmFyaWFudCk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIHdoZXRoZXIgYSB2YXJpYW50IGNhbiBiZSBhZGRlZCB3aXRob3V0IGV4Y2VlZGluZyBsaW1pdHMuXG4gICAqIEBwYXJhbSB2YXJpYW50IC0gVGhlIHZhcmlhbnQgdG8gdmFsaWRhdGVcbiAgICogQHJldHVybnMgQXJyYXkgb2YgdmFsaWRhdGlvbiBlcnJvciBtZXNzYWdlcywgZW1wdHkgaWYgdmFsaWRcbiAgICovXG4gIHByaXZhdGUgdmFsaWRhdGVWYXJpYW50QWRkaXRpb24gPSAodmFyaWFudDogSVByb21wdFZhcmlhbnQpOiBzdHJpbmdbXSA9PiB7XG4gICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgLy8gQ2hlY2sgaWYgYWRkaW5nIHRoaXMgdmFyaWFudCB3b3VsZCBleGNlZWQgdGhlIG1heGltdW1cbiAgICBpZiAodGhpcy52YXJpYW50cy5sZW5ndGggPj0gUHJvbXB0Lk1BWF9WQVJJQU5UUykge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgIGBDYW5ub3QgYWRkIHZhcmlhbnQgdG8gcHJvbXB0ICcke3RoaXMucHJvbXB0TmFtZX0nLiBNYXhpbXVtIG9mICR7UHJvbXB0Lk1BWF9WQVJJQU5UU30gdmFyaWFudHMgYWxsb3dlZCwgY3VycmVudGx5IGhhdmUgJHt0aGlzLnZhcmlhbnRzLmxlbmd0aH0uYCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGR1cGxpY2F0ZSB2YXJpYW50IG5hbWVzXG4gICAgaWYgKHRoaXMudmFyaWFudHMuZmluZCh2ID0+IHYubmFtZSA9PT0gdmFyaWFudC5uYW1lKSkge1xuICAgICAgZXJyb3JzLnB1c2goYFZhcmlhbnQgd2l0aCBuYW1lICcke3ZhcmlhbnQubmFtZX0nIGFscmVhZHkgZXhpc3RzLmApO1xuICAgIH1cblxuICAgIHJldHVybiBlcnJvcnM7XG4gIH07XG59XG4iXX0=