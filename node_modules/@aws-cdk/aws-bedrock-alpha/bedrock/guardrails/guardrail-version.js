"use strict";
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GuardrailVersion = exports.GuardrailVersionBase = void 0;
const aws_cdk_lib_1 = require("aws-cdk-lib");
const aws_bedrock_1 = require("aws-cdk-lib/aws-bedrock");
const helpers_internal_1 = require("aws-cdk-lib/core/lib/helpers-internal");
const metadata_resource_1 = require("aws-cdk-lib/core/lib/metadata-resource");
const prop_injectable_1 = require("aws-cdk-lib/core/lib/prop-injectable");
// Internal Libs
const guardrails_1 = require("./guardrails");
/******************************************************************************
 *                        ABSTRACT BASE CLASS
 *****************************************************************************/
/**
 * Abstract base class for a Guardrail Version.
 * Contains methods and attributes valid for Guardrail Versions either created
 * with CDK or imported.
 */
class GuardrailVersionBase extends aws_cdk_lib_1.Resource {
    constructor(scope, id) {
        super(scope, id);
    }
}
exports.GuardrailVersionBase = GuardrailVersionBase;
/******************************************************************************
 *                        NEW CONSTRUCT DEFINITION
 *****************************************************************************/
/**
 * Class to create a Guardrail Version with CDK.
 * @cloudformationResource AWS::Bedrock::GuardrailVersion
 */
let GuardrailVersion = (() => {
    let _classDecorators = [prop_injectable_1.propertyInjectable];
    let _classDescriptor;
    let _classExtraInitializers = [];
    let _classThis;
    let _classSuper = GuardrailVersionBase;
    var GuardrailVersion = class extends _classSuper {
        static { _classThis = this; }
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
            GuardrailVersion = _classThis = _classDescriptor.value;
            if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        /** Uniquely identifies this class. */
        static PROPERTY_INJECTION_ID = '@aws-cdk.aws-bedrock-alpha.GuardrailVersion';
        /**
         * Import a Guardrail Version from its attributes.
         */
        static fromGuardrailVersionAttributes(scope, id, attrs) {
            class Import extends GuardrailVersionBase {
                guardrail = guardrails_1.Guardrail.fromGuardrailAttributes(scope, `Guardrail-${id}`, {
                    guardrailArn: attrs.guardrailArn,
                    guardrailVersion: attrs.guardrailVersion,
                });
                guardrailVersion = attrs.guardrailVersion;
            }
            return new Import(scope, id);
        }
        guardrail;
        guardrailVersion;
        /**
         * The underlying CfnGuardrailVersion resource.
         */
        _resource;
        /**
         *
         */
        constructor(scope, id, props) {
            super(scope, id);
            // Enhanced CDK Analytics Telemetry
            (0, metadata_resource_1.addConstructMetadata)(this, props);
            this.guardrail = props.guardrail;
            // Compute hash from guardrail, to recreate the resource when guardrail has changed
            const hash = (0, helpers_internal_1.md5hash)(props.guardrail.lastUpdated ?? 'Default');
            this._resource = new aws_bedrock_1.CfnGuardrailVersion(this, `GuardrailVersion-${hash.slice(0, 16)}`, {
                guardrailIdentifier: this.guardrail.guardrailId,
                description: props.description,
            });
            this.guardrailVersion = this._resource.attrVersion;
        }
        static {
            __runInitializers(_classThis, _classExtraInitializers);
        }
    };
    return GuardrailVersion = _classThis;
})();
exports.GuardrailVersion = GuardrailVersion;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3VhcmRyYWlsLXZlcnNpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJndWFyZHJhaWwtdmVyc2lvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsNkNBQWtEO0FBQ2xELHlEQUE4RDtBQUM5RCw0RUFBZ0U7QUFDaEUsOEVBQThFO0FBQzlFLDBFQUEwRTtBQUUxRSxnQkFBZ0I7QUFDaEIsNkNBQXFEO0FBcUJyRDs7K0VBRStFO0FBRS9FOzs7O0dBSUc7QUFDSCxNQUFzQixvQkFBcUIsU0FBUSxzQkFBUTtJQUd6RCxZQUFZLEtBQWdCLEVBQUUsRUFBVTtRQUN0QyxLQUFLLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0tBQ2xCO0NBQ0Y7QUFORCxvREFNQztBQTJDRDs7K0VBRStFO0FBQy9FOzs7R0FHRztJQUVVLGdCQUFnQjs0QkFENUIsb0NBQWtCOzs7O3NCQUNtQixvQkFBb0I7Z0NBQTVCLFNBQVEsV0FBb0I7Ozs7WUFBMUQsNktBZ0RDOzs7O1FBL0NDLHNDQUFzQztRQUMvQixNQUFNLENBQVUscUJBQXFCLEdBQVcsNkNBQTZDLENBQUM7UUFFckc7O1dBRUc7UUFDSSxNQUFNLENBQUMsOEJBQThCLENBQzFDLEtBQWdCLEVBQ2hCLEVBQVUsRUFDVixLQUFpQztZQUVqQyxNQUFNLE1BQU8sU0FBUSxvQkFBb0I7Z0JBQ3ZCLFNBQVMsR0FBRyxzQkFBUyxDQUFDLHVCQUF1QixDQUFDLEtBQUssRUFBRSxhQUFhLEVBQUUsRUFBRSxFQUFFO29CQUN0RixZQUFZLEVBQUUsS0FBSyxDQUFDLFlBQVk7b0JBQ2hDLGdCQUFnQixFQUFFLEtBQUssQ0FBQyxnQkFBZ0I7aUJBQ3pDLENBQUMsQ0FBQztnQkFDYSxnQkFBZ0IsR0FBRyxLQUFLLENBQUMsZ0JBQWdCLENBQUM7YUFDM0Q7WUFDRCxPQUFPLElBQUksTUFBTSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztTQUM5QjtRQUVlLFNBQVMsQ0FBYTtRQUN0QixnQkFBZ0IsQ0FBUztRQUN6Qzs7V0FFRztRQUNjLFNBQVMsQ0FBc0I7UUFFaEQ7O1dBRUc7UUFDSCxZQUFZLEtBQWdCLEVBQUUsRUFBVSxFQUFFLEtBQTRCO1lBQ3BFLEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDakIsbUNBQW1DO1lBQ25DLElBQUEsd0NBQW9CLEVBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQ2xDLElBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQztZQUVqQyxtRkFBbUY7WUFDbkYsTUFBTSxJQUFJLEdBQUcsSUFBQSwwQkFBTyxFQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsV0FBVyxJQUFJLFNBQVMsQ0FBQyxDQUFDO1lBRS9ELElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxpQ0FBbUIsQ0FBQyxJQUFJLEVBQUUsb0JBQW9CLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ3RGLG1CQUFtQixFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVztnQkFDL0MsV0FBVyxFQUFFLEtBQUssQ0FBQyxXQUFXO2FBQy9CLENBQUMsQ0FBQztZQUVILElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQztTQUNwRDs7WUEvQ1UsdURBQWdCOzs7OztBQUFoQiw0Q0FBZ0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJUmVzb3VyY2UsIFJlc291cmNlIH0gZnJvbSAnYXdzLWNkay1saWInO1xuaW1wb3J0IHsgQ2ZuR3VhcmRyYWlsVmVyc2lvbiB9IGZyb20gJ2F3cy1jZGstbGliL2F3cy1iZWRyb2NrJztcbmltcG9ydCB7IG1kNWhhc2ggfSBmcm9tICdhd3MtY2RrLWxpYi9jb3JlL2xpYi9oZWxwZXJzLWludGVybmFsJztcbmltcG9ydCB7IGFkZENvbnN0cnVjdE1ldGFkYXRhIH0gZnJvbSAnYXdzLWNkay1saWIvY29yZS9saWIvbWV0YWRhdGEtcmVzb3VyY2UnO1xuaW1wb3J0IHsgcHJvcGVydHlJbmplY3RhYmxlIH0gZnJvbSAnYXdzLWNkay1saWIvY29yZS9saWIvcHJvcC1pbmplY3RhYmxlJztcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gJ2NvbnN0cnVjdHMnO1xuLy8gSW50ZXJuYWwgTGlic1xuaW1wb3J0IHsgR3VhcmRyYWlsLCBJR3VhcmRyYWlsIH0gZnJvbSAnLi9ndWFyZHJhaWxzJztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDT01NT05cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKlxuICogUmVwcmVzZW50cyBhIEd1YXJkcmFpbCBWZXJzaW9uLCBlaXRoZXIgY3JlYXRlZCB3aXRoIENESyBvciBpbXBvcnRlZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJR3VhcmRyYWlsVmVyc2lvbiBleHRlbmRzIElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBUaGUgR3VhcmRyYWlsIHRvIHdoaWNoIHRoaXMgdmVyc2lvbiBiZWxvbmdzLlxuICAgKi9cbiAgcmVhZG9ubHkgZ3VhcmRyYWlsOiBJR3VhcmRyYWlsO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIGd1YXJkcmFpbCB2ZXJzaW9uLlxuICAgKiBAZXhhbXBsZSBcIjFcIlxuICAgKi9cbiAgcmVhZG9ubHkgZ3VhcmRyYWlsVmVyc2lvbjogc3RyaW5nO1xufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIEFCU1RSQUNUIEJBU0UgQ0xBU1NcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBhIEd1YXJkcmFpbCBWZXJzaW9uLlxuICogQ29udGFpbnMgbWV0aG9kcyBhbmQgYXR0cmlidXRlcyB2YWxpZCBmb3IgR3VhcmRyYWlsIFZlcnNpb25zIGVpdGhlciBjcmVhdGVkXG4gKiB3aXRoIENESyBvciBpbXBvcnRlZC5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEd1YXJkcmFpbFZlcnNpb25CYXNlIGV4dGVuZHMgUmVzb3VyY2UgaW1wbGVtZW50cyBJR3VhcmRyYWlsVmVyc2lvbiB7XG4gIHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSBndWFyZHJhaWw6IElHdWFyZHJhaWw7XG4gIHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSBndWFyZHJhaWxWZXJzaW9uOiBzdHJpbmc7XG4gIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcpIHtcbiAgICBzdXBlcihzY29wZSwgaWQpO1xuICB9XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgICAgICAgICAgICAgICAgICAgICAgUFJPUFMgRk9SIE5FVyBDT05TVFJVQ1RcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKlxuICogUHJvcGVydGllcyBmb3IgY3JlYXRpbmcgYSBDREstTWFuYWdlZCBHdWFyZHJhaWwgVmVyc2lvbi5cbiAqL1xuXG4vKipcbiAqIFByb3BlcnRpZXMgZm9yIGNyZWF0aW5nIGEgR3VhcmRyYWlsIFZlcnNpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR3VhcmRyYWlsVmVyc2lvblByb3BzIHtcbiAgLyoqXG4gICAqIFRoZSBndWFyZHJhaWwgdG8gY3JlYXRlIGEgdmVyc2lvbiBmb3IuXG4gICAqL1xuICByZWFkb25seSBndWFyZHJhaWw6IElHdWFyZHJhaWw7XG4gIC8qKlxuICAgKiBUaGUgZGVzY3JpcHRpb24gb2YgdGhlIGd1YXJkcmFpbCB2ZXJzaW9uLlxuICAgKlxuICAgKiBAZXhhbXBsZSBcIlRoaXMgaXMgYSBkZXNjcmlwdGlvbiBvZiB0aGUgZ3VhcmRyYWlsIHZlcnNpb24uXCJcbiAgICogQGRlZmF1bHQgLSBObyBkZXNjcmlwdGlvbiBpcyBwcm92aWRlZC5cbiAgICovXG4gIHJlYWRvbmx5IGRlc2NyaXB0aW9uPzogc3RyaW5nO1xufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgICAgICAgICAgICAgICAgICAgICBBVFRSUyBGT1IgSU1QT1JURUQgQ09OU1RSVUNUXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKipcbiAqIEF0dHJpYnV0ZXMgbmVlZGVkIHRvIGNyZWF0ZSBhbiBpbXBvcnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHdWFyZHJhaWxWZXJzaW9uQXR0cmlidXRlcyB7XG4gIC8qKlxuICAgKiBUaGUgQVJOIG9mIHRoZSBndWFyZHJhaWwuXG4gICAqL1xuICByZWFkb25seSBndWFyZHJhaWxBcm46IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgZ3VhcmRyYWlsIHZlcnNpb24uXG4gICAqIEBleGFtcGxlIFwiMVwiXG4gICAqL1xuICByZWFkb25seSBndWFyZHJhaWxWZXJzaW9uOiBzdHJpbmc7XG59XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIE5FVyBDT05TVFJVQ1QgREVGSU5JVElPTlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqXG4gKiBDbGFzcyB0byBjcmVhdGUgYSBHdWFyZHJhaWwgVmVyc2lvbiB3aXRoIENESy5cbiAqIEBjbG91ZGZvcm1hdGlvblJlc291cmNlIEFXUzo6QmVkcm9jazo6R3VhcmRyYWlsVmVyc2lvblxuICovXG5AcHJvcGVydHlJbmplY3RhYmxlXG5leHBvcnQgY2xhc3MgR3VhcmRyYWlsVmVyc2lvbiBleHRlbmRzIEd1YXJkcmFpbFZlcnNpb25CYXNlIHtcbiAgLyoqIFVuaXF1ZWx5IGlkZW50aWZpZXMgdGhpcyBjbGFzcy4gKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBQUk9QRVJUWV9JTkpFQ1RJT05fSUQ6IHN0cmluZyA9ICdAYXdzLWNkay5hd3MtYmVkcm9jay1hbHBoYS5HdWFyZHJhaWxWZXJzaW9uJztcblxuICAvKipcbiAgICogSW1wb3J0IGEgR3VhcmRyYWlsIFZlcnNpb24gZnJvbSBpdHMgYXR0cmlidXRlcy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbUd1YXJkcmFpbFZlcnNpb25BdHRyaWJ1dGVzKFxuICAgIHNjb3BlOiBDb25zdHJ1Y3QsXG4gICAgaWQ6IHN0cmluZyxcbiAgICBhdHRyczogR3VhcmRyYWlsVmVyc2lvbkF0dHJpYnV0ZXMsXG4gICk6IElHdWFyZHJhaWxWZXJzaW9uIHtcbiAgICBjbGFzcyBJbXBvcnQgZXh0ZW5kcyBHdWFyZHJhaWxWZXJzaW9uQmFzZSB7XG4gICAgICBwdWJsaWMgcmVhZG9ubHkgZ3VhcmRyYWlsID0gR3VhcmRyYWlsLmZyb21HdWFyZHJhaWxBdHRyaWJ1dGVzKHNjb3BlLCBgR3VhcmRyYWlsLSR7aWR9YCwge1xuICAgICAgICBndWFyZHJhaWxBcm46IGF0dHJzLmd1YXJkcmFpbEFybixcbiAgICAgICAgZ3VhcmRyYWlsVmVyc2lvbjogYXR0cnMuZ3VhcmRyYWlsVmVyc2lvbixcbiAgICAgIH0pO1xuICAgICAgcHVibGljIHJlYWRvbmx5IGd1YXJkcmFpbFZlcnNpb24gPSBhdHRycy5ndWFyZHJhaWxWZXJzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEltcG9ydChzY29wZSwgaWQpO1xuICB9XG5cbiAgcHVibGljIHJlYWRvbmx5IGd1YXJkcmFpbDogSUd1YXJkcmFpbDtcbiAgcHVibGljIHJlYWRvbmx5IGd1YXJkcmFpbFZlcnNpb246IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSB1bmRlcmx5aW5nIENmbkd1YXJkcmFpbFZlcnNpb24gcmVzb3VyY2UuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IF9yZXNvdXJjZTogQ2ZuR3VhcmRyYWlsVmVyc2lvbjtcblxuICAvKipcbiAgICpcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBHdWFyZHJhaWxWZXJzaW9uUHJvcHMpIHtcbiAgICBzdXBlcihzY29wZSwgaWQpO1xuICAgIC8vIEVuaGFuY2VkIENESyBBbmFseXRpY3MgVGVsZW1ldHJ5XG4gICAgYWRkQ29uc3RydWN0TWV0YWRhdGEodGhpcywgcHJvcHMpO1xuICAgIHRoaXMuZ3VhcmRyYWlsID0gcHJvcHMuZ3VhcmRyYWlsO1xuXG4gICAgLy8gQ29tcHV0ZSBoYXNoIGZyb20gZ3VhcmRyYWlsLCB0byByZWNyZWF0ZSB0aGUgcmVzb3VyY2Ugd2hlbiBndWFyZHJhaWwgaGFzIGNoYW5nZWRcbiAgICBjb25zdCBoYXNoID0gbWQ1aGFzaChwcm9wcy5ndWFyZHJhaWwubGFzdFVwZGF0ZWQgPz8gJ0RlZmF1bHQnKTtcblxuICAgIHRoaXMuX3Jlc291cmNlID0gbmV3IENmbkd1YXJkcmFpbFZlcnNpb24odGhpcywgYEd1YXJkcmFpbFZlcnNpb24tJHtoYXNoLnNsaWNlKDAsIDE2KX1gLCB7XG4gICAgICBndWFyZHJhaWxJZGVudGlmaWVyOiB0aGlzLmd1YXJkcmFpbC5ndWFyZHJhaWxJZCxcbiAgICAgIGRlc2NyaXB0aW9uOiBwcm9wcy5kZXNjcmlwdGlvbixcbiAgICB9KTtcblxuICAgIHRoaXMuZ3VhcmRyYWlsVmVyc2lvbiA9IHRoaXMuX3Jlc291cmNlLmF0dHJWZXJzaW9uO1xuICB9XG59XG4iXX0=