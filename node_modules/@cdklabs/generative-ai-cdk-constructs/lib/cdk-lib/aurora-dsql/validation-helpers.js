"use strict";
/**
 *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance
 *  with the License. A copy of the License is located at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  or in the 'license' file accompanying this file. This file is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES
 *  OR CONDITIONS OF ANY KIND, express or implied. See the License for the specific language governing permissions
 *  and limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidationError = void 0;
exports.validateStringFieldLength = validateStringFieldLength;
exports.validateFieldPattern = validateFieldPattern;
exports.throwIfInvalid = throwIfInvalid;
const aws_cdk_lib_1 = require("aws-cdk-lib");
/**
 * Error thrown when validation fails
 */
class ValidationError extends Error {
    constructor(message) {
        super(message);
        this.name = 'ValidationError';
    }
}
exports.ValidationError = ValidationError;
/**
 * Validates the length of a string field against minimum and maximum constraints.
 * @param value - The string value to validate
 * @param fieldName - Name of the field being validated (for error messages)
 * @param minLength - Minimum allowed length (defaults to 0)
 * @param maxLength - Maximum allowed length
 * @returns true if validation passes
 * @throws Error if validation fails with current length information
 */
function validateStringFieldLength(params) {
    const errors = [];
    // Handle null/undefined values
    if (params.value == null) {
        return errors; // Skip validation for null/undefined values
    }
    const currentLength = params.value.length;
    // Evaluate only if it is not an unresolved Token
    if (!aws_cdk_lib_1.Token.isUnresolved(params.fieldName)) {
        if (params.value.length > params.maxLength) {
            errors.push(`The field ${params.fieldName} is ${currentLength} characters long but must be less than or equal to ${params.maxLength} characters`);
        }
        if (params.value.length < params.minLength) {
            errors.push(`The field ${params.fieldName} is ${currentLength} characters long but must be at least ${params.minLength} characters`);
        }
    }
    return errors;
}
/**
 * Validates a string field against a regex pattern.
 * @param value - The string value to validate
 * @param fieldName - Name of the field being validated (for error messages)
 * @param pattern - Regular expression pattern to test against
 * @param customMessage - Optional custom error message
 * @returns true if validation passes
 * @throws Error if validation fails with detailed message
 */
function validateFieldPattern(value, fieldName, pattern, customMessage) {
    const errors = [];
    // Handle null/undefined values
    if (value == null) {
        return errors; // Skip validation for null/undefined values
    }
    // Evaluate only if it is not an unresolved Token
    if (!aws_cdk_lib_1.Token.isUnresolved(value)) {
        // Verify type
        if (typeof value !== 'string') {
            errors.push(`Expected string for ${fieldName}, got ${typeof value}`);
        }
        // Validate specified regex
        if (!(pattern instanceof RegExp)) {
            errors.push('Pattern must be a valid regular expression');
        }
        // Pattern validation
        if (!pattern.test(value)) {
            const defaultMessage = `The field ${fieldName} with value "${value}" does not match the required pattern ${pattern}`;
            errors.push(customMessage || defaultMessage);
        }
    }
    return errors;
}
function throwIfInvalid(validationFn, param) {
    const errors = validationFn(param);
    if (errors.length > 0) {
        throw new ValidationError(errors.join('\n'));
    }
    return param;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdGlvbi1oZWxwZXJzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2Nkay1saWIvYXVyb3JhLWRzcWwvdmFsaWRhdGlvbi1oZWxwZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7R0FXRzs7O0FBZ0NILDhEQTBCQztBQVdELG9EQWdDQztBQUlELHdDQU1DO0FBN0dELDZDQUFvQztBQUVwQzs7R0FFRztBQUNILE1BQWEsZUFBZ0IsU0FBUSxLQUFLO0lBQ3hDLFlBQVksT0FBZTtRQUN6QixLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDZixJQUFJLENBQUMsSUFBSSxHQUFHLGlCQUFpQixDQUFDO0lBQ2hDLENBQUM7Q0FDRjtBQUxELDBDQUtDO0FBV0Q7Ozs7Ozs7O0dBUUc7QUFDSCxTQUFnQix5QkFBeUIsQ0FBQyxNQUE4QjtJQUN0RSxNQUFNLE1BQU0sR0FBYSxFQUFFLENBQUM7SUFFNUIsK0JBQStCO0lBQy9CLElBQUksTUFBTSxDQUFDLEtBQUssSUFBSSxJQUFJLEVBQUUsQ0FBQztRQUN6QixPQUFPLE1BQU0sQ0FBQyxDQUFDLDRDQUE0QztJQUM3RCxDQUFDO0lBRUQsTUFBTSxhQUFhLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7SUFFMUMsaURBQWlEO0lBQ2pELElBQUksQ0FBQyxtQkFBSyxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQztRQUMxQyxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUMzQyxNQUFNLENBQUMsSUFBSSxDQUNULGFBQWEsTUFBTSxDQUFDLFNBQVMsT0FBTyxhQUFhLHNEQUFzRCxNQUFNLENBQUMsU0FBUyxhQUFhLENBQ3JJLENBQUM7UUFDSixDQUFDO1FBRUQsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDM0MsTUFBTSxDQUFDLElBQUksQ0FDVCxhQUFhLE1BQU0sQ0FBQyxTQUFTLE9BQU8sYUFBYSx5Q0FBeUMsTUFBTSxDQUFDLFNBQVMsYUFBYSxDQUN4SCxDQUFDO1FBQ0osQ0FBQztJQUNILENBQUM7SUFFRCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBRUQ7Ozs7Ozs7O0dBUUc7QUFDSCxTQUFnQixvQkFBb0IsQ0FDbEMsS0FBYSxFQUNiLFNBQWlCLEVBQ2pCLE9BQWUsRUFDZixhQUFzQjtJQUV0QixNQUFNLE1BQU0sR0FBYSxFQUFFLENBQUM7SUFFNUIsK0JBQStCO0lBQy9CLElBQUksS0FBSyxJQUFJLElBQUksRUFBRSxDQUFDO1FBQ2xCLE9BQU8sTUFBTSxDQUFDLENBQUMsNENBQTRDO0lBQzdELENBQUM7SUFFRCxpREFBaUQ7SUFDakQsSUFBSSxDQUFDLG1CQUFLLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7UUFDL0IsY0FBYztRQUNkLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxFQUFFLENBQUM7WUFDOUIsTUFBTSxDQUFDLElBQUksQ0FBQyx1QkFBdUIsU0FBUyxTQUFTLE9BQU8sS0FBSyxFQUFFLENBQUMsQ0FBQztRQUN2RSxDQUFDO1FBQ0QsMkJBQTJCO1FBQzNCLElBQUksQ0FBQyxDQUFDLE9BQU8sWUFBWSxNQUFNLENBQUMsRUFBRSxDQUFDO1lBQ2pDLE1BQU0sQ0FBQyxJQUFJLENBQUMsNENBQTRDLENBQUMsQ0FBQztRQUM1RCxDQUFDO1FBRUQscUJBQXFCO1FBQ3JCLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7WUFDekIsTUFBTSxjQUFjLEdBQUcsYUFBYSxTQUFTLGdCQUFnQixLQUFLLHlDQUF5QyxPQUFPLEVBQUUsQ0FBQztZQUNySCxNQUFNLENBQUMsSUFBSSxDQUFDLGFBQWEsSUFBSSxjQUFjLENBQUMsQ0FBQztRQUMvQyxDQUFDO0lBQ0gsQ0FBQztJQUVELE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUM7QUFJRCxTQUFnQixjQUFjLENBQUksWUFBNkIsRUFBRSxLQUFRO0lBQ3ZFLE1BQU0sTUFBTSxHQUFHLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNuQyxJQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7UUFDdEIsTUFBTSxJQUFJLGVBQWUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUNELE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpLiBZb3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiAgd2l0aCB0aGUgTGljZW5zZS4gQSBjb3B5IG9mIHRoZSBMaWNlbnNlIGlzIGxvY2F0ZWQgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBvciBpbiB0aGUgJ2xpY2Vuc2UnIGZpbGUgYWNjb21wYW55aW5nIHRoaXMgZmlsZS4gVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFU1xuICogIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXG4gKiAgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFRva2VuIH0gZnJvbSAnYXdzLWNkay1saWInO1xuXG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIHZhbGlkYXRpb24gZmFpbHNcbiAqL1xuZXhwb3J0IGNsYXNzIFZhbGlkYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ1ZhbGlkYXRpb25FcnJvcic7XG4gIH1cbn1cbmludGVyZmFjZSBJbnRlcnZhbFZhbGlkYXRpb24ge1xuICBmaWVsZE5hbWU6IHN0cmluZztcbiAgbWluTGVuZ3RoOiBudW1iZXI7XG4gIG1heExlbmd0aDogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgU3RyaW5nTGVuZ3RoVmFsaWRhdGlvbiBleHRlbmRzIEludGVydmFsVmFsaWRhdGlvbiB7XG4gIHZhbHVlOiBzdHJpbmc7XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIHRoZSBsZW5ndGggb2YgYSBzdHJpbmcgZmllbGQgYWdhaW5zdCBtaW5pbXVtIGFuZCBtYXhpbXVtIGNvbnN0cmFpbnRzLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZyB2YWx1ZSB0byB2YWxpZGF0ZVxuICogQHBhcmFtIGZpZWxkTmFtZSAtIE5hbWUgb2YgdGhlIGZpZWxkIGJlaW5nIHZhbGlkYXRlZCAoZm9yIGVycm9yIG1lc3NhZ2VzKVxuICogQHBhcmFtIG1pbkxlbmd0aCAtIE1pbmltdW0gYWxsb3dlZCBsZW5ndGggKGRlZmF1bHRzIHRvIDApXG4gKiBAcGFyYW0gbWF4TGVuZ3RoIC0gTWF4aW11bSBhbGxvd2VkIGxlbmd0aFxuICogQHJldHVybnMgdHJ1ZSBpZiB2YWxpZGF0aW9uIHBhc3Nlc1xuICogQHRocm93cyBFcnJvciBpZiB2YWxpZGF0aW9uIGZhaWxzIHdpdGggY3VycmVudCBsZW5ndGggaW5mb3JtYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlU3RyaW5nRmllbGRMZW5ndGgocGFyYW1zOiBTdHJpbmdMZW5ndGhWYWxpZGF0aW9uKTogc3RyaW5nW10ge1xuICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XG5cbiAgLy8gSGFuZGxlIG51bGwvdW5kZWZpbmVkIHZhbHVlc1xuICBpZiAocGFyYW1zLnZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gZXJyb3JzOyAvLyBTa2lwIHZhbGlkYXRpb24gZm9yIG51bGwvdW5kZWZpbmVkIHZhbHVlc1xuICB9XG5cbiAgY29uc3QgY3VycmVudExlbmd0aCA9IHBhcmFtcy52YWx1ZS5sZW5ndGg7XG5cbiAgLy8gRXZhbHVhdGUgb25seSBpZiBpdCBpcyBub3QgYW4gdW5yZXNvbHZlZCBUb2tlblxuICBpZiAoIVRva2VuLmlzVW5yZXNvbHZlZChwYXJhbXMuZmllbGROYW1lKSkge1xuICAgIGlmIChwYXJhbXMudmFsdWUubGVuZ3RoID4gcGFyYW1zLm1heExlbmd0aCkge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgIGBUaGUgZmllbGQgJHtwYXJhbXMuZmllbGROYW1lfSBpcyAke2N1cnJlbnRMZW5ndGh9IGNoYXJhY3RlcnMgbG9uZyBidXQgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJHtwYXJhbXMubWF4TGVuZ3RofSBjaGFyYWN0ZXJzYCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy52YWx1ZS5sZW5ndGggPCBwYXJhbXMubWluTGVuZ3RoKSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgYFRoZSBmaWVsZCAke3BhcmFtcy5maWVsZE5hbWV9IGlzICR7Y3VycmVudExlbmd0aH0gY2hhcmFjdGVycyBsb25nIGJ1dCBtdXN0IGJlIGF0IGxlYXN0ICR7cGFyYW1zLm1pbkxlbmd0aH0gY2hhcmFjdGVyc2AsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlcnJvcnM7XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIGEgc3RyaW5nIGZpZWxkIGFnYWluc3QgYSByZWdleCBwYXR0ZXJuLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZyB2YWx1ZSB0byB2YWxpZGF0ZVxuICogQHBhcmFtIGZpZWxkTmFtZSAtIE5hbWUgb2YgdGhlIGZpZWxkIGJlaW5nIHZhbGlkYXRlZCAoZm9yIGVycm9yIG1lc3NhZ2VzKVxuICogQHBhcmFtIHBhdHRlcm4gLSBSZWd1bGFyIGV4cHJlc3Npb24gcGF0dGVybiB0byB0ZXN0IGFnYWluc3RcbiAqIEBwYXJhbSBjdXN0b21NZXNzYWdlIC0gT3B0aW9uYWwgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHRydWUgaWYgdmFsaWRhdGlvbiBwYXNzZXNcbiAqIEB0aHJvd3MgRXJyb3IgaWYgdmFsaWRhdGlvbiBmYWlscyB3aXRoIGRldGFpbGVkIG1lc3NhZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRmllbGRQYXR0ZXJuKFxuICB2YWx1ZTogc3RyaW5nLFxuICBmaWVsZE5hbWU6IHN0cmluZyxcbiAgcGF0dGVybjogUmVnRXhwLFxuICBjdXN0b21NZXNzYWdlPzogc3RyaW5nLFxuKTogc3RyaW5nW10ge1xuICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XG5cbiAgLy8gSGFuZGxlIG51bGwvdW5kZWZpbmVkIHZhbHVlc1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBlcnJvcnM7IC8vIFNraXAgdmFsaWRhdGlvbiBmb3IgbnVsbC91bmRlZmluZWQgdmFsdWVzXG4gIH1cblxuICAvLyBFdmFsdWF0ZSBvbmx5IGlmIGl0IGlzIG5vdCBhbiB1bnJlc29sdmVkIFRva2VuXG4gIGlmICghVG9rZW4uaXNVbnJlc29sdmVkKHZhbHVlKSkge1xuICAgIC8vIFZlcmlmeSB0eXBlXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9ycy5wdXNoKGBFeHBlY3RlZCBzdHJpbmcgZm9yICR7ZmllbGROYW1lfSwgZ290ICR7dHlwZW9mIHZhbHVlfWApO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSBzcGVjaWZpZWQgcmVnZXhcbiAgICBpZiAoIShwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwKSkge1xuICAgICAgZXJyb3JzLnB1c2goJ1BhdHRlcm4gbXVzdCBiZSBhIHZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbicpO1xuICAgIH1cblxuICAgIC8vIFBhdHRlcm4gdmFsaWRhdGlvblxuICAgIGlmICghcGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgY29uc3QgZGVmYXVsdE1lc3NhZ2UgPSBgVGhlIGZpZWxkICR7ZmllbGROYW1lfSB3aXRoIHZhbHVlIFwiJHt2YWx1ZX1cIiBkb2VzIG5vdCBtYXRjaCB0aGUgcmVxdWlyZWQgcGF0dGVybiAke3BhdHRlcm59YDtcbiAgICAgIGVycm9ycy5wdXNoKGN1c3RvbU1lc3NhZ2UgfHwgZGVmYXVsdE1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlcnJvcnM7XG59XG5cbmV4cG9ydCB0eXBlIFZhbGlkYXRpb25GbjxUPiA9IChwYXJhbTogVCkgPT4gc3RyaW5nW107XG5cbmV4cG9ydCBmdW5jdGlvbiB0aHJvd0lmSW52YWxpZDxUPih2YWxpZGF0aW9uRm46IFZhbGlkYXRpb25GbjxUPiwgcGFyYW06IFQpOiBUIHtcbiAgY29uc3QgZXJyb3JzID0gdmFsaWRhdGlvbkZuKHBhcmFtKTtcbiAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihlcnJvcnMuam9pbignXFxuJykpO1xuICB9XG4gIHJldHVybiBwYXJhbTtcbn1cbiJdfQ==